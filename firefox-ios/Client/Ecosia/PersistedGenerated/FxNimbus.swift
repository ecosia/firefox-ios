// This file was autogenerated by the `nimbus-fml` crate.
// Trust me, you don't want to mess with it!
#if canImport(Foundation)
    import Foundation
#endif
#if canImport(MozillaAppServices)
    import MozillaAppServices
#endif
#if canImport(UIKit)
    import UIKit
#endif

///
/// An object for safely accessing feature configuration from Nimbus.
///
/// This is generated.
public class FxNimbus : FeatureManifestInterface {
    public typealias Features = FxNimbusFeatures

    ///
    /// This should be populated at app launch; this method of initializing features
    /// will be removed in favor of the `initialize` function.
    ///
    public var api: FeaturesInterface?

    ///
    /// This method should be called as early in the startup sequence of the app as possible.
    /// This is to connect the Nimbus SDK (and thus server) with the `FxNimbus`
    /// class.
    ///
    /// The lambda MUST be threadsafe in its own right.
    public func initialize(with getSdk: @escaping () -> FeaturesInterface?) {
        self.getSdk = getSdk
        self.features.accountSettingsReduxFeature.with(sdk: getSdk)
        self.features.addressAutofillEdit.with(sdk: getSdk)
        self.features.bookmarkRefactorFeature.with(sdk: getSdk)
        self.features.contextualHintFeature.with(sdk: getSdk)
        self.features.creditCardAutofill.with(sdk: getSdk)
        self.features.feltPrivacyFeature.with(sdk: getSdk)
        self.features.firefoxSuggestFeature.with(sdk: getSdk)
        self.features.generalAppFeatures.with(sdk: getSdk)
        self.features.gleanServerKnobs.with(sdk: getSdk)
        self.features.homepageRebuildFeature.with(sdk: getSdk)
        self.features.homescreenFeature.with(sdk: getSdk)
        self.features.loginAutofill.with(sdk: getSdk)
        self.features.menuRefactorFeature.with(sdk: getSdk)
        self.features.microsurveyFeature.with(sdk: getSdk)
        self.features.nativeErrorPageFeature.with(sdk: getSdk)
        self.features.nightModeFeature.with(sdk: getSdk)
        self.features.onboardingFrameworkFeature.with(sdk: getSdk)
        self.features.passwordGeneratorFeature.with(sdk: getSdk)
        self.features.reduxSearchSettingsFeature.with(sdk: getSdk)
        self.features.remoteTabManagement.with(sdk: getSdk)
        self.features.search.with(sdk: getSdk)
        self.features.shopping2023.with(sdk: getSdk)
        self.features.splashScreen.with(sdk: getSdk)
        self.features.spotlightSearch.with(sdk: getSdk)
        self.features.tabTrayRefactorFeature.with(sdk: getSdk)
        self.features.tabTrayFeature.with(sdk: getSdk)
        self.features.toolbarRefactorFeature.with(sdk: getSdk)
        self.features.trackingProtectionRefactor.with(sdk: getSdk)
        self.features.zoomFeature.with(sdk: getSdk)
        FxNimbusMessaging.shared.initialize(with: getSdk)
        self.reinitialize()
    }

    fileprivate lazy var getSdk: GetSdk = { [self] in self.api }

    ///
    /// Represents all the features supported by Nimbus
    ///
    public let features = Features()

    public func getCoenrollingFeatureIds() -> [String] {
        ["messaging"]
    }

    /// Introspection utility method.
    public func getFeature(featureId: String) -> FeatureHolderAny? {
        switch featureId {
            case "account-settings-redux-feature": return FeatureHolderAny(wrapping: features.accountSettingsReduxFeature)
            case "address-autofill-edit": return FeatureHolderAny(wrapping: features.addressAutofillEdit)
            case "bookmark-refactor-feature": return FeatureHolderAny(wrapping: features.bookmarkRefactorFeature)
            case "contextual-hint-feature": return FeatureHolderAny(wrapping: features.contextualHintFeature)
            case "credit-card-autofill": return FeatureHolderAny(wrapping: features.creditCardAutofill)
            case "felt-privacy-feature": return FeatureHolderAny(wrapping: features.feltPrivacyFeature)
            case "firefox-suggest-feature": return FeatureHolderAny(wrapping: features.firefoxSuggestFeature)
            case "general-app-features": return FeatureHolderAny(wrapping: features.generalAppFeatures)
            case "glean-server-knobs": return FeatureHolderAny(wrapping: features.gleanServerKnobs)
            case "homepage-rebuild-feature": return FeatureHolderAny(wrapping: features.homepageRebuildFeature)
            case "homescreenFeature": return FeatureHolderAny(wrapping: features.homescreenFeature)
            case "login-autofill": return FeatureHolderAny(wrapping: features.loginAutofill)
            case "menu-refactor-feature": return FeatureHolderAny(wrapping: features.menuRefactorFeature)
            case "microsurvey-feature": return FeatureHolderAny(wrapping: features.microsurveyFeature)
            case "native-error-page-feature": return FeatureHolderAny(wrapping: features.nativeErrorPageFeature)
            case "night-mode-feature": return FeatureHolderAny(wrapping: features.nightModeFeature)
            case "onboarding-framework-feature": return FeatureHolderAny(wrapping: features.onboardingFrameworkFeature)
            case "password-generator-feature": return FeatureHolderAny(wrapping: features.passwordGeneratorFeature)
            case "redux-search-settings-feature": return FeatureHolderAny(wrapping: features.reduxSearchSettingsFeature)
            case "remote-tab-management": return FeatureHolderAny(wrapping: features.remoteTabManagement)
            case "search": return FeatureHolderAny(wrapping: features.search)
            case "shopping2023": return FeatureHolderAny(wrapping: features.shopping2023)
            case "splash-screen": return FeatureHolderAny(wrapping: features.splashScreen)
            case "spotlight-search": return FeatureHolderAny(wrapping: features.spotlightSearch)
            case "tab-tray-refactor-feature": return FeatureHolderAny(wrapping: features.tabTrayRefactorFeature)
            case "tabTrayFeature": return FeatureHolderAny(wrapping: features.tabTrayFeature)
            case "toolbar-refactor-feature": return FeatureHolderAny(wrapping: features.toolbarRefactorFeature)
            case "tracking-protection-refactor": return FeatureHolderAny(wrapping: features.trackingProtectionRefactor)
            case "zoom-feature": return FeatureHolderAny(wrapping: features.zoomFeature)
            default: return nil
        }
    }

    ///
    /// All generated initialization code. Clients shouldn't need to override or call
    /// this.
    /// We put it in a separate method because we have to be quite careful about what order
    /// the initialization happens inâ€” e.g. when importing other FML files.
    ///
    private func reinitialize() {
        
        FxNimbusMessaging.shared.features.messaging.with(initializer: { variables, prefs in
            Messaging(
                variables,
                prefs,
                actions: ["OPEN_SETTINGS": "://deep-link?url=settings/general", "OPEN_SETTINGS_NEW_TAB": "://deep-link?url=settings/newtab", "OPEN_SETTINGS_HOMESCREEN": "://deep-link?url=settings/homepage", "OPEN_SETTINGS_WALLPAPERS": "://deep-link?url=settings/wallpaper", "OPEN_SETTINGS_EMAIL": "://deep-link?url=settings/mailto", "OPEN_SETTINGS_SEARCH_ENGINE": "://deep-link?url=settings/search", "OPEN_SETTINGS_PRIVACY": "://deep-link?url=settings/clear-private-data", "OPEN_SETTINGS_FXA": "://deep-link?url=settings/fxa", "OPEN_SETTINGS_THEME": "://deep-link?url=settings/theme", "OPEN_URL": "://open-url", "VIEW_BOOKMARKS": "://deep-link?url=homepanel/bookmarks", "VIEW_TOP_SITES": "://deep-link?url=homepanel/top-sites", "VIEW_READING_LIST": "://deep-link?url=homepanel/reading-list", "VIEW_HISTORY": "://deep-link?url=homepanel/history", "VIEW_DOWNLOADS": "://deep-link?url=homepanel/downloads", "ENABLE_PRIVATE_BROWSING": "://deep-link?url=homepanel/new-private-tab", "OPEN_NEW_TAB": "://deep-link?url=homepanel/new-tab", "MAKE_DEFAULT_BROWSER": "://deep-link?url=default-browser/system-settings", "MAKE_DEFAULT_BROWSER_WITH_TUTORIAL": "://deep-link?url=default-browser/tutorial"],
                messageUnderExperiment: nil,
                messages: ["default-browser": MessageData(action: "MAKE_DEFAULT_BROWSER_WITH_TUTORIAL", buttonLabel: "Default Browser/DefaultBrowserCard.Button.v2", exceptIfAny: ["I_AM_DEFAULT_BROWSER"], style: "FALLBACK", surface: .newTabCard, text: "Default Browser/DefaultBrowserCard.Description", title: "Default Browser/DefaultBrowserCard.Title", triggerIfAll: ["SUPPORTS_DEFAULT_BROWSER", "ON_FOURTH_LAUNCH_THIS_YEAR"]), "homepage-microsurvey-message": MessageData(buttonLabel: "Microsurvey/Microsurvey.Prompt.Button.v127", microsurveyConfig: MicrosurveyConfig(icon: "homeLarge", options: ["Microsurvey/Microsurvey.Survey.Options.VerySatisfied.v132", "Microsurvey/Microsurvey.Survey.Options.Satisfied.v132", "Microsurvey/Microsurvey.Survey.Options.Neutral.v132", "Microsurvey/Microsurvey.Survey.Options.Dissatisfied.v132", "Microsurvey/Microsurvey.Survey.Options.VeryDissatisfied.v132", "Microsurvey/Microsurvey.Survey.Options.NotApplicable.v132"], utmContent: "homepage"), style: "MICROSURVEY", surface: .microsurvey, text: "How satisfied are you with your Firefox homepage?", title: "Microsurvey/Microsurvey.Prompt.TitleLabel.v127", triggerIfAll: ["SECOND_HOMEPAGE_VIEW"]), "survey-surface-message": MessageData(action: "OPEN_URL", actionParams: ["url": "https://www.macrumors.com"], buttonLabel: "ResearchSurface/PrimaryButton.Label.v112", style: "SURVEY", surface: .survey, text: "ResearchSurface/Body.Text.v112", triggerIfAll: ["NEVER"])],
                onControl: .showNextMessage,
                styles: ["FALLBACK": StyleData(maxDisplayCount: 20, priority: 40), "DEFAULT": StyleData(maxDisplayCount: 5, priority: 50), "MICROSURVEY": StyleData(maxDisplayCount: 1, priority: 50), "NOTIFICATION": StyleData(maxDisplayCount: 1, priority: 50), "PERSISTENT": StyleData(maxDisplayCount: 20, priority: 50), "SURVEY": StyleData(maxDisplayCount: 10, priority: 55), "WARNING": StyleData(maxDisplayCount: 10, priority: 60), "URGENT": StyleData(maxDisplayCount: 10, priority: 100)],
                triggers: ["ALWAYS": "true", "NEVER": "false", "USER_RECENTLY_INSTALLED": "days_since_install < 7", "USER_RECENTLY_UPDATED": "days_since_update < 7 && days_since_install != days_since_update", "USER_TIER_ONE_COUNTRY": "('US' in locale || 'GB' in locale || 'CA' in locale || 'DE' in locale || 'FR' in locale)", "USER_EN_SPEAKER": "'en' in locale", "USER_ES_SPEAKER": "'es' in locale", "USER_DE_SPEAKER": "'de' in locale", "USER_FR_SPEAKER": "'fr' in locale", "DEVICE_ANDROID": "os == 'Android'", "DEVICE_IOS": "os == 'iOS'", "DAY_1_AFTER_INSTALL": "days_since_install == 1", "DAY_2_AFTER_INSTALL": "days_since_install == 2", "DAY_3_AFTER_INSTALL": "days_since_install == 3", "DAY_4_AFTER_INSTALL": "days_since_install == 4", "DAY_5_AFTER_INSTALL": "days_since_install == 5", "MORE_THAN_24H_SINCE_INSTALLED_OR_UPDATED": "days_since_update >= 1", "NOT_LAUNCHED_YESTERDAY": "'app_cycle.foreground'|eventLastSeen('Days', 1) > 1", "AFTER_THREE_LAUNCHES_THIS_WEEK": "'app_cycle.foreground'|eventSum('Weeks', 1, 0) >= 3", "I_AM_DEFAULT_BROWSER": "is_default_browser", "I_AM_NOT_DEFAULT_BROWSER": "is_default_browser == false", "SUPPORTS_DEFAULT_BROWSER": "os_version|versionCompare('14.!') >= 0", "INACTIVE_NEW_USER": "is_inactive_new_user", "ALLOWED_TIPS_NOTIFICATIONS": "allowed_tips_notifications", "FXA_CURRENTLY_SIGNED_IN": "is_fxa_signed_in == true", "SECOND_HOMEPAGE_VIEW": "'homepage_viewed'|eventSum('Years', 4, 0) >= 2", "ON_FOURTH_LAUNCH_THIS_YEAR": "'app_cycle.foreground'|eventSum('Years', 1, 0) > 3"],
                experiment: "{experiment}"
            )
        })
    }

    ///
    /// Refresh the cache of configuration objects.
    ///
    /// For performance reasons, the feature configurations are constructed once then cached.
    /// This method is to clear that cache for all features configured with Nimbus.
    ///
    /// It must be called whenever the Nimbus SDK finishes the `applyPendingExperiments()` method.
    ///
    public func invalidateCachedValues() {
        features.accountSettingsReduxFeature.with(cachedValue: nil)
        features.addressAutofillEdit.with(cachedValue: nil)
        features.bookmarkRefactorFeature.with(cachedValue: nil)
        features.contextualHintFeature.with(cachedValue: nil)
        features.creditCardAutofill.with(cachedValue: nil)
        features.feltPrivacyFeature.with(cachedValue: nil)
        features.firefoxSuggestFeature.with(cachedValue: nil)
        features.generalAppFeatures.with(cachedValue: nil)
        features.gleanServerKnobs.with(cachedValue: nil)
        features.homepageRebuildFeature.with(cachedValue: nil)
        features.homescreenFeature.with(cachedValue: nil)
        features.loginAutofill.with(cachedValue: nil)
        features.menuRefactorFeature.with(cachedValue: nil)
        features.microsurveyFeature.with(cachedValue: nil)
        features.nativeErrorPageFeature.with(cachedValue: nil)
        features.nightModeFeature.with(cachedValue: nil)
        features.onboardingFrameworkFeature.with(cachedValue: nil)
        features.passwordGeneratorFeature.with(cachedValue: nil)
        features.reduxSearchSettingsFeature.with(cachedValue: nil)
        features.remoteTabManagement.with(cachedValue: nil)
        features.search.with(cachedValue: nil)
        features.shopping2023.with(cachedValue: nil)
        features.splashScreen.with(cachedValue: nil)
        features.spotlightSearch.with(cachedValue: nil)
        features.tabTrayRefactorFeature.with(cachedValue: nil)
        features.tabTrayFeature.with(cachedValue: nil)
        features.toolbarRefactorFeature.with(cachedValue: nil)
        features.trackingProtectionRefactor.with(cachedValue: nil)
        features.zoomFeature.with(cachedValue: nil)
        FxNimbusMessaging.shared.invalidateCachedValues()
    }

    ///
    /// A singleton instance of FxNimbus
    ///
    public static let shared = FxNimbus()
}

public class FxNimbusFeatures {
    /// This feature is for managing the roll out of the Account Settings Redux
         /// implementation
         /// 
    public lazy var accountSettingsReduxFeature: FeatureHolder<AccountSettingsReduxFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "account-settings-redux-feature") { variables, prefs in
            AccountSettingsReduxFeature(variables, prefs)
        }
    }()
    /// This property defines if the address editing is enabled in Settings
    public lazy var addressAutofillEdit: FeatureHolder<AddressAutofillEdit> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "address-autofill-edit") { variables, prefs in
            AddressAutofillEdit(variables, prefs)
        }
    }()
    /// The Feature for managing the roll out of the Bookmark refactor feature
         /// 
    public lazy var bookmarkRefactorFeature: FeatureHolder<BookmarkRefactorFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "bookmark-refactor-feature") { variables, prefs in
            BookmarkRefactorFeature(variables, prefs)
        }
    }()
    /// This set holds all features pertaining to contextual hints.
    public lazy var contextualHintFeature: FeatureHolder<ContextualHintFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "contextual-hint-feature") { variables, prefs in
            ContextualHintFeature(variables, prefs)
        }
    }()
    /// This property defines the credit card autofill feature
    public lazy var creditCardAutofill: FeatureHolder<CreditCardAutofill> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "credit-card-autofill") { variables, prefs in
            CreditCardAutofill(variables, prefs)
        }
    }()
    /// The feature that enhances private browsing mode
    public lazy var feltPrivacyFeature: FeatureHolder<FeltPrivacyFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "felt-privacy-feature") { variables, prefs in
            FeltPrivacyFeature(variables, prefs)
        }
    }()
    /// Configuration for the Firefox Suggest feature.
    public lazy var firefoxSuggestFeature: FeatureHolder<FirefoxSuggestFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "firefox-suggest-feature") { variables, prefs in
            FirefoxSuggestFeature(variables, prefs)
        }
    }()
    /// The feature that contains feature flags for the entire application
    public lazy var generalAppFeatures: FeatureHolder<GeneralAppFeatures> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "general-app-features") { variables, prefs in
            GeneralAppFeatures(variables, prefs)
        }
    }()
    /// A feature that provides server-side configurations for Glean metrics (aka
         /// Server Knobs).
    public lazy var gleanServerKnobs: FeatureHolder<GleanServerKnobs> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "glean-server-knobs") { variables, prefs in
            GleanServerKnobs(variables, prefs)
        }
    }()
    /// This feature is for managing the roll out of the Homepage rebuild feature
         /// 
    public lazy var homepageRebuildFeature: FeatureHolder<HomepageRebuildFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "homepage-rebuild-feature") { variables, prefs in
            HomepageRebuildFeature(variables, prefs)
        }
    }()
    /// The homescreen that the user goes to when they press home or new tab.
    public lazy var homescreenFeature: FeatureHolder<HomescreenFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "homescreenFeature") { variables, prefs in
            HomescreenFeature(variables, prefs)
        }
    }()
    /// This property defines the login autofill feature for automatically filling
         /// in usernames and passwords.
    public lazy var loginAutofill: FeatureHolder<LoginAutofill> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "login-autofill") { variables, prefs in
            LoginAutofill(variables, prefs)
        }
    }()
    /// Controls the menu refactor feature
         /// 
    public lazy var menuRefactorFeature: FeatureHolder<MenuRefactorFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "menu-refactor-feature") { variables, prefs in
            MenuRefactorFeature(variables, prefs)
        }
    }()
    /// A feature that shows the microsurvey for users to interact with and submit
         /// responses.
         /// 
    public lazy var microsurveyFeature: FeatureHolder<MicrosurveyFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "microsurvey-feature") { variables, prefs in
            MicrosurveyFeature(variables, prefs)
        }
    }()
    /// This feature is for managing the roll out of the native error page feature
         /// 
    public lazy var nativeErrorPageFeature: FeatureHolder<NativeErrorPageFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "native-error-page-feature") { variables, prefs in
            NativeErrorPageFeature(variables, prefs)
        }
    }()
    /// Describes the night mode feature's configuration
         /// 
    public lazy var nightModeFeature: FeatureHolder<NightModeFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "night-mode-feature") { variables, prefs in
            NightModeFeature(variables, prefs)
        }
    }()
    /// The new onboarding framework feature that will allow onboarding to be
         /// experimentable through initial experiments.
         /// 
    public lazy var onboardingFrameworkFeature: FeatureHolder<OnboardingFrameworkFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "onboarding-framework-feature") { variables, prefs in
            OnboardingFrameworkFeature(variables, prefs)
        }
    }()
    /// Password Generator Feature
    public lazy var passwordGeneratorFeature: FeatureHolder<PasswordGeneratorFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "password-generator-feature") { variables, prefs in
            PasswordGeneratorFeature(variables, prefs)
        }
    }()
    /// This feature is for managing the roll out of redux on the search settings
         /// screen
         /// 
    public lazy var reduxSearchSettingsFeature: FeatureHolder<ReduxSearchSettingsFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "redux-search-settings-feature") { variables, prefs in
            ReduxSearchSettingsFeature(variables, prefs)
        }
    }()
    /// Features that let users manage tabs on other devices that are connected to
         /// the same Mozilla account.
         /// 
    public lazy var remoteTabManagement: FeatureHolder<RemoteTabManagement> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "remote-tab-management") { variables, prefs in
            RemoteTabManagement(variables, prefs)
        }
    }()
    /// Configuring the functionality to do with search. This will be separated into
         /// smaller sub-features in later releases.
         /// 
    public lazy var search: FeatureHolder<Search> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "search") { variables, prefs in
            Search(variables, prefs)
        }
    }()
    /// The configuration setting for the status of the Fakespot feature
         /// 
    public lazy var shopping2023: FeatureHolder<Shopping2023> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "shopping2023") { variables, prefs in
            Shopping2023(variables, prefs)
        }
    }()
    /// A feature that extends splash screen duration, allowing additional data
         /// fetching time for the app's initial run.
         /// 
    public lazy var splashScreen: FeatureHolder<SplashScreen> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "splash-screen") { variables, prefs in
            SplashScreen(variables, prefs)
        }
    }()
    /// Add pages as items findable with Spotlight.
    public lazy var spotlightSearch: FeatureHolder<SpotlightSearch> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "spotlight-search") { variables, prefs in
            SpotlightSearch(variables, prefs)
        }
    }()
    /// This feature is for managing the roll out of the Tab Tray refactor feature
         /// 
    public lazy var tabTrayRefactorFeature: FeatureHolder<TabTrayRefactorFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "tab-tray-refactor-feature") { variables, prefs in
            TabTrayRefactorFeature(variables, prefs)
        }
    }()
    /// The tab tray screen that the user goes to when they open the tab tray.
    public lazy var tabTrayFeature: FeatureHolder<TabTrayFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "tabTrayFeature") { variables, prefs in
            TabTrayFeature(variables, prefs)
        }
    }()
    /// This feature is for managing the roll out of the Toolbar refactor feature
         /// 
    public lazy var toolbarRefactorFeature: FeatureHolder<ToolbarRefactorFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "toolbar-refactor-feature") { variables, prefs in
            ToolbarRefactorFeature(variables, prefs)
        }
    }()
    /// The Enhanced Tracking Protection refactor
         /// 
    public lazy var trackingProtectionRefactor: FeatureHolder<TrackingProtectionRefactor> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "tracking-protection-refactor") { variables, prefs in
            TrackingProtectionRefactor(variables, prefs)
        }
    }()
    /// The configuration for the status of the zoom feature
         /// 
    public lazy var zoomFeature: FeatureHolder<ZoomFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "zoom-feature") { variables, prefs in
            ZoomFeature(variables, prefs)
        }
    }()
}

// Public interface members begin here.

/// This feature is for managing the roll out of the Account Settings Redux
 /// implementation
 /// 
public class AccountSettingsReduxFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
    }

    /// Enables the feature
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
}
extension AccountSettingsReduxFeature: FMLFeatureInterface {}
/// This property defines if the address editing is enabled in Settings
public class AddressAutofillEdit: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let status: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        status: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            status: status))
    }

    enum CodingKeys: String, CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(status, forKey: .status)
    }

    /// If true, we will allow user to edit the address
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
    
}
extension AddressAutofillEdit: FMLFeatureInterface {}
/// The Feature for managing the roll out of the Bookmark refactor feature
 /// 
public class BookmarkRefactorFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
    }

    /// Enables the bookmark refactor feature
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
}
extension BookmarkRefactorFeature: FMLFeatureInterface {}
/// This set holds all features pertaining to contextual hints.
public class ContextualHintFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let featuresEnabled: [ContextualHint: Bool]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        featuresEnabled: [ContextualHint: Bool] = [.toolbarHint: true]
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            featuresEnabled: featuresEnabled))
    }

    enum CodingKeys: String, CodingKey {
        case featuresEnabled = "features-enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(featuresEnabled.mapKeysNotNull { $0.rawValue }, forKey: .featuresEnabled)
    }

    /// This property provides a lookup table of whether specific contextual hints
     /// are enabled.
     /// 
    public lazy var featuresEnabled: [ContextualHint: Bool] = {
        self._variables.getBoolMap("features-enabled")?.mapKeysNotNull(ContextualHint.enumValue).mergeWith(_defaults.featuresEnabled) ?? _defaults.featuresEnabled
    }()
    
}
extension ContextualHintFeature: FMLFeatureInterface {}
/// This property defines the credit card autofill feature
public class CreditCardAutofill: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let creditCardAutofillStatus: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        creditCardAutofillStatus: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            creditCardAutofillStatus: creditCardAutofillStatus))
    }

    enum CodingKeys: String, CodingKey {
        case creditCardAutofillStatus = "credit-card-autofill-status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(creditCardAutofillStatus, forKey: .creditCardAutofillStatus)
    }

    /// If true, we will allow user to use the credit autofill feature
    public lazy var creditCardAutofillStatus: Bool = {
        self._variables.getBool("credit-card-autofill-status") ?? _defaults.creditCardAutofillStatus
    }()
    
}
extension CreditCardAutofill: FMLFeatureInterface {}
/// The feature that enhances private browsing mode
public class FeltPrivacyFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let feltDeletionEnabled: Bool
        let simplifiedUiEnabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        feltDeletionEnabled: Bool = true,
        simplifiedUiEnabled: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            feltDeletionEnabled: feltDeletionEnabled,
            simplifiedUiEnabled: simplifiedUiEnabled))
    }

    enum CodingKeys: String, CodingKey {
        case feltDeletionEnabled = "felt-deletion-enabled"
        case simplifiedUiEnabled = "simplified-ui-enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(feltDeletionEnabled, forKey: .feltDeletionEnabled)
        try container.encode(simplifiedUiEnabled, forKey: .simplifiedUiEnabled)
    }

    /// If true, enable Felt Deletion part of Felt Privacy
    public lazy var feltDeletionEnabled: Bool = {
        self._variables.getBool("felt-deletion-enabled") ?? _defaults.feltDeletionEnabled
    }()
    
    /// If true, enable simplified UI part of Felt Privacy
    public lazy var simplifiedUiEnabled: Bool = {
        self._variables.getBool("simplified-ui-enabled") ?? _defaults.simplifiedUiEnabled
    }()
    
}
extension FeltPrivacyFeature: FMLFeatureInterface {}
/// Configuration for the Firefox Suggest feature.
public class FirefoxSuggestFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let availableSuggestionsTypes: [SuggestionType: Bool]
        let status: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        availableSuggestionsTypes: [SuggestionType: Bool] = [.amp: true, .ampMobile: false, .wikipedia: true],
        status: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            availableSuggestionsTypes: availableSuggestionsTypes,
            status: status))
    }

    enum CodingKeys: String, CodingKey {
        case availableSuggestionsTypes = "available-suggestions-types"
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(availableSuggestionsTypes.mapKeysNotNull { $0.rawValue }, forKey: .availableSuggestionsTypes)
        try container.encode(status, forKey: .status)
    }

    /// A map of suggestion types to booleans that indicate whether or not the
     /// provider should return suggestions of those types.
     /// 
    public lazy var availableSuggestionsTypes: [SuggestionType: Bool] = {
        self._variables.getBoolMap("available-suggestions-types")?.mapKeysNotNull(SuggestionType.enumValue).mergeWith(_defaults.availableSuggestionsTypes) ?? _defaults.availableSuggestionsTypes
    }()
    
    /// Whether the feature is enabled. When Firefox Suggest is enabled, Firefox
     /// will download and store new search suggestions in the background, and
     /// show additional Search settings to control which suggestions appear
     /// in the awesomebar. When Firefox Suggest is disabled, Firefox will not
     /// download new suggestions, and hide the additional Search settings.
     /// 
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
    
}
extension FirefoxSuggestFeature: FMLFeatureInterface {}
/// The feature that contains feature flags for the entire application
public class GeneralAppFeatures: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let reportSiteIssue: GeneralFeature
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        reportSiteIssue: GeneralFeature = GeneralFeature(status: true)
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            reportSiteIssue: reportSiteIssue))
    }

    enum CodingKeys: String, CodingKey {
        case reportSiteIssue = "report-site-issue"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(reportSiteIssue, forKey: .reportSiteIssue)
    }

    /// This property defines whether or not the feature is enabled
    public lazy var reportSiteIssue: GeneralFeature = {
        self._variables.getVariables("report-site-issue")?.map(GeneralFeature.create)._mergeWith(_defaults.reportSiteIssue) ?? _defaults.reportSiteIssue
    }()
    
}
extension GeneralAppFeatures: FMLFeatureInterface {}
/// A feature that provides server-side configurations for Glean metrics (aka
 /// Server Knobs).
public class GleanServerKnobs: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let metricsEnabled: [String: Bool]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        metricsEnabled: [String: Bool] = [:]
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            metricsEnabled: metricsEnabled))
    }

    enum CodingKeys: String, CodingKey {
        case metricsEnabled = "metrics-enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(metricsEnabled, forKey: .metricsEnabled)
    }

    /// A map of metric base-identifiers to booleans representing the state of the
     /// 'enabled' flag for that metric.
    public lazy var metricsEnabled: [String: Bool] = {
        self._variables.getBoolMap("metrics-enabled")?.mergeWith(_defaults.metricsEnabled) ?? _defaults.metricsEnabled
    }()
    
}
extension GleanServerKnobs: FMLFeatureInterface {}
/// This feature is for managing the roll out of the Homepage rebuild feature
 /// 
public class HomepageRebuildFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
    }

    /// If true, enables the feature
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
}
extension HomepageRebuildFeature: FMLFeatureInterface {}
/// The homescreen that the user goes to when they press home or new tab.
public class HomescreenFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let preferSwitchToOpenTab: Bool
        let sectionsEnabled: [HomeScreenSection: Bool]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        preferSwitchToOpenTab: Bool = true,
        sectionsEnabled: [HomeScreenSection: Bool] = [.jumpBackIn: true, .recentExplorations: false]
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            preferSwitchToOpenTab: preferSwitchToOpenTab,
            sectionsEnabled: sectionsEnabled))
    }

    enum CodingKeys: String, CodingKey {
        case preferSwitchToOpenTab = "prefer-switch-to-open-tab"
        case sectionsEnabled = "sections-enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(preferSwitchToOpenTab, forKey: .preferSwitchToOpenTab)
        try container.encode(sectionsEnabled.mapKeysNotNull { $0.rawValue }, forKey: .sectionsEnabled)
    }

    /// Enables the feature to automatically switch to an existing tab with the same
     /// content instead of opening a new one.
     /// 
    public lazy var preferSwitchToOpenTab: Bool = {
        self._variables.getBool("prefer-switch-to-open-tab") ?? _defaults.preferSwitchToOpenTab
    }()
    
    /// This property provides a lookup table of whether or not the given section
     /// should be enabled. If the section is enabled, it should be toggleable
     /// in the settings screen, and on by default.
     /// 
    public lazy var sectionsEnabled: [HomeScreenSection: Bool] = {
        self._variables.getBoolMap("sections-enabled")?.mapKeysNotNull(HomeScreenSection.enumValue).mergeWith(_defaults.sectionsEnabled) ?? _defaults.sectionsEnabled
    }()
    
}
extension HomescreenFeature: FMLFeatureInterface {}
/// This property defines the login autofill feature for automatically filling
 /// in usernames and passwords.
public class LoginAutofill: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let loginAutofillStatus: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        loginAutofillStatus: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            loginAutofillStatus: loginAutofillStatus))
    }

    enum CodingKeys: String, CodingKey {
        case loginAutofillStatus = "login-autofill-status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(loginAutofillStatus, forKey: .loginAutofillStatus)
    }

    /// If true, allows the user to use the login autofill feature for usernames
     /// and passwords.
    public lazy var loginAutofillStatus: Bool = {
        self._variables.getBool("login-autofill-status") ?? _defaults.loginAutofillStatus
    }()
    
}
extension LoginAutofill: FMLFeatureInterface {}
/// Controls the menu refactor feature
 /// 
public class MenuRefactorFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
        let menuHint: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = false,
        menuHint: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled,
            menuHint: menuHint))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
        case menuHint = "menu-hint"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
        try container.encode(menuHint, forKey: .menuHint)
    }

    /// Controls which menu users will see
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
    /// If true, enables the menu contextual hint.
     /// 
    public lazy var menuHint: Bool = {
        self._variables.getBool("menu-hint") ?? _defaults.menuHint
    }()
    
}
extension MenuRefactorFeature: FMLFeatureInterface {}
/// A feature that shows the microsurvey for users to interact with and submit
 /// responses.
 /// 
public class MicrosurveyFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
    }

    /// If true, the feature is active.
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
}
extension MicrosurveyFeature: FMLFeatureInterface {}
/// This feature is for managing the roll out of the native error page feature
 /// 
public class NativeErrorPageFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
    }

    /// If true, the feature is active.
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
}
extension NativeErrorPageFeature: FMLFeatureInterface {}
/// Describes the night mode feature's configuration
 /// 
public class NightModeFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
    }

    /// Whether night mode is available for users or not
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
}
extension NightModeFeature: FMLFeatureInterface {}
/// The new onboarding framework feature that will allow onboarding to be
 /// experimentable through initial experiments.
 /// 
public class OnboardingFrameworkFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let cards: [String: NimbusOnboardingCardData]
        let conditions: [String: String]
        let dismissable: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        cards: [String: NimbusOnboardingCardData] = ["welcome": NimbusOnboardingCardData(body: "Onboarding/Onboarding.Welcome.Description.TreatementA.v120", buttons: NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .openInstructionsPopup, title: "Onboarding/Onboarding.Welcome.ActionTreatementA.v114"), secondary: NimbusOnboardingButton(action: .forwardOneCard, title: "Onboarding/Onboarding.Welcome.Skip.v114")), cardType: .basic, image: .welcomeGlobe, instructionsPopup: NimbusOnboardingInstructionPopup(buttonAction: .openIosFxSettings, buttonTitle: "Onboarding/DefaultBrowserPopup.ButtonTitle.v114", instructions: ["Onboarding/DefaultBrowserPopup.FirstLabel.v114", "Onboarding/DefaultBrowserPopup.SecondLabel.v114", "Onboarding/DefaultBrowserPopup.ThirdLabel.v114"], title: "Onboarding/DefaultBrowserPopup.Title.v114"), link: NimbusOnboardingLink(title: "Onboarding/Onboarding.Welcome.Link.Action.v114", url: "https://www.mozilla.org/privacy/firefox/"), onboardingType: .freshInstall, order: 10, prerequisites: ["ALWAYS"], title: "Onboarding/Onboarding.Welcome.Title.TreatementA.v120"), "notification-permissions": NimbusOnboardingCardData(body: "Onboarding/Onboarding.Notification.Description.v120", buttons: NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .requestNotifications, title: "Onboarding/Onboarding.Notification.TurnOnNotifications.Action.v114"), secondary: NimbusOnboardingButton(action: .forwardOneCard, title: "Onboarding/Onboarding.Notification.Skip.Action.v115")), cardType: .basic, image: .notifications, onboardingType: .freshInstall, order: 30, prerequisites: ["ALWAYS"], title: "Onboarding/Onboarding.Notification.Title.v120"), "sign-to-sync": NimbusOnboardingCardData(body: "Onboarding/Onboarding.Sync.Description.v123", buttons: NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .syncSignIn, title: "Onboarding/Onboarding.Sync.SignIn.Action.v114"), secondary: NimbusOnboardingButton(action: .forwardOneCard, title: "Onboarding/Onboarding.Sync.Skip.Action.v114")), cardType: .basic, image: .syncDevices, onboardingType: .freshInstall, order: 20, prerequisites: ["ALWAYS"], title: "Onboarding/Onboarding.Sync.Title.v120"), "customization-theme": NimbusOnboardingCardData(body: "Onboarding/Onboarding.Customization.Theme.Description.v123", buttons: NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .forwardOneCard, title: "Onboarding/Onboarding.Customization.Theme.Continue.Action.v123")), cardType: .multipleChoice, image: .themeing, multipleChoiceButtons: [NimbusOnboardingMultipleChoiceButton(action: .themeSystemDefault, image: .themeSystem, title: "Onboarding/Onboarding.Customization.Theme.System.Action.v123"), NimbusOnboardingMultipleChoiceButton(action: .themeLight, image: .themeLight, title: "Onboarding/Onboarding.Customization.Theme.Light.Action.v123"), NimbusOnboardingMultipleChoiceButton(action: .themeDark, image: .themeDark, title: "Onboarding/Onboarding.Customization.Theme.Dark.Action.v123")], onboardingType: .freshInstall, order: 40, prerequisites: ["ALWAYS"], title: "Onboarding/Onboarding.Customization.Theme.Title.v123"), "customization-toolbar": NimbusOnboardingCardData(body: "Onboarding/Onboarding.Customization.Toolbar.Description.v123", buttons: NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .forwardOneCard, title: "Onboarding/Onboarding.Customization.Toolbar.Continue.Action.v123")), cardType: .multipleChoice, image: .toolbar, multipleChoiceButtons: [NimbusOnboardingMultipleChoiceButton(action: .toolbarTop, image: .toolbarTop, title: "Onboarding/Onboarding.Customization.Toolbar.Top.Action.v123"), NimbusOnboardingMultipleChoiceButton(action: .toolbarBottom, image: .toolbarBottom, title: "Onboarding/Onboarding.Customization.Toolbar.Bottom.Action.v123")], onboardingType: .freshInstall, order: 41, prerequisites: ["ALWAYS"], title: "Onboarding/Onboarding.Customization.Toolbar.Title.v123"), "update-welcome": NimbusOnboardingCardData(body: "Upgrade/Upgrade.Welcome.Description.v114", buttons: NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .forwardOneCard, title: "Upgrade/Upgrade.Welcome.Action.v114")), cardType: .basic, image: .welcomeGlobe, onboardingType: .upgrade, order: 10, prerequisites: ["NEVER"], title: "Upgrade/Upgrade.Welcome.Title.v114"), "update-sign-to-sync": NimbusOnboardingCardData(body: "Upgrade/Upgrade.SyncSign.Description.v114", buttons: NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .syncSignIn, title: "Upgrade/Upgrade.SyncSign.Action.v114"), secondary: NimbusOnboardingButton(action: .forwardOneCard, title: "Onboarding/Onboarding.LaterAction.v114")), cardType: .basic, image: .syncDevices, onboardingType: .upgrade, order: 20, prerequisites: ["NEVER"], title: "Upgrade/Upgrade.SyncSign.Title.v114")],
        conditions: [String: String] = ["ALWAYS": "true", "NEVER": "false"],
        dismissable: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            cards: cards,
            conditions: conditions,
            dismissable: dismissable))
    }

    enum CodingKeys: String, CodingKey {
        case cards = "cards"
        case conditions = "conditions"
        case dismissable = "dismissable"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(cards, forKey: .cards)
        try container.encode(conditions, forKey: .conditions)
        try container.encode(dismissable, forKey: .dismissable)
    }

    /// The list of available cards for onboarding.
     /// 
    public lazy var cards: [String: NimbusOnboardingCardData] = {
        self._variables.getVariablesMap("cards")?.mapValuesNotNull(NimbusOnboardingCardData.create).mergeWith(_defaults.cards, NimbusOnboardingCardData.mergeWith) ?? _defaults.cards
    }()
    
    /// A collection of out the box conditional expressions to be used in
     /// determining whether a card should show or not. Each entry maps to a
     /// valid JEXL expression.
     /// 
    public lazy var conditions: [String: String] = {
        self._variables.getStringMap("conditions")?.mergeWith(_defaults.conditions) ?? _defaults.conditions
    }()
    
    /// Whether or not the entire onboarding is dismissable by pressing an X at the
     /// top right corner of the screen.
     /// 
    public lazy var dismissable: Bool = {
        self._variables.getBool("dismissable") ?? _defaults.dismissable
    }()
    
}
extension OnboardingFrameworkFeature: FMLFeatureInterface {}
/// Password Generator Feature
public class PasswordGeneratorFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
    }

    /// If true, the password generator feature is enabled
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
}
extension PasswordGeneratorFeature: FMLFeatureInterface {}
/// This feature is for managing the roll out of redux on the search settings
 /// screen
 /// 
public class ReduxSearchSettingsFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
    }

    /// Enables the feature
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
}
extension ReduxSearchSettingsFeature: FMLFeatureInterface {}
/// Features that let users manage tabs on other devices that are connected to
 /// the same Mozilla account.
 /// 
public class RemoteTabManagement: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let closeTabsEnabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        closeTabsEnabled: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            closeTabsEnabled: closeTabsEnabled))
    }

    enum CodingKeys: String, CodingKey {
        case closeTabsEnabled = "close-tabs-enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(closeTabsEnabled, forKey: .closeTabsEnabled)
    }

    /// Whether the feature to close synced tabs is enabled. When enabled, this
     /// device will allow other devices to close tabs that are open on this
     /// device, and show a "close" button for tabs that are currently open on
     /// other supported devices in the synced tabs tray.
     /// 
    public lazy var closeTabsEnabled: Bool = {
        self._variables.getBool("close-tabs-enabled") ?? _defaults.closeTabsEnabled
    }()
    
}
extension RemoteTabManagement: FMLFeatureInterface {}
/// Configuring the functionality to do with search. This will be separated into
 /// smaller sub-features in later releases.
 /// 
public class Search: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let awesomeBar: AwesomeBar
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        awesomeBar: AwesomeBar = AwesomeBar(minSearchTerm: 3, position: SearchBarPositionFeature(isBottom: false, isPositionFeatureEnabled: true, isToolbarCfrOn: false), searchHighlights: false, usePageContent: false)
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            awesomeBar: awesomeBar))
    }

    enum CodingKeys: String, CodingKey {
        case awesomeBar = "awesome-bar"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(awesomeBar, forKey: .awesomeBar)
    }

    /// Configuring the awesome bar.
    public lazy var awesomeBar: AwesomeBar = {
        self._variables.getVariables("awesome-bar")?.map(AwesomeBar.create)._mergeWith(_defaults.awesomeBar) ?? _defaults.awesomeBar
    }()
    
}
extension Search: FMLFeatureInterface {}
/// The configuration setting for the status of the Fakespot feature
 /// 
public class Shopping2023: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let backInStockReporting: Bool
        let config: [String: WebsiteConfig]
        let productAds: Bool
        let relay: String
        let status: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        backInStockReporting: Bool = false,
        config: [String: WebsiteConfig] = ["amazon": WebsiteConfig(productIdFromUrlRegex: "(?:[\\/]|$|%2F)(?<productId>[A-Z0-9]{10})(?:[\\/]|$|\\#|\\?|%2F)", validTlDs: ["com", "de", "fr"]), "walmart": WebsiteConfig(productIdFromUrlRegex: "\\/ip\\/(?:[A-Za-z0-9-]{1,320}\\/)?(?<productId>[0-9]{3,13})", validTlDs: ["com"]), "bestbuy": WebsiteConfig(productIdFromUrlRegex: "\\/(?<productId>\\d+\\.p)", validTlDs: ["com"])],
        productAds: Bool = false,
        relay: String = "https://mozilla-ohttp-fakespot.fastly-edge.com/",
        status: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            backInStockReporting: backInStockReporting,
            config: config,
            productAds: productAds,
            relay: relay,
            status: status))
    }

    enum CodingKeys: String, CodingKey {
        case backInStockReporting = "back_in_stock_reporting"
        case config = "config"
        case productAds = "product_ads"
        case relay = "relay"
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(backInStockReporting, forKey: .backInStockReporting)
        try container.encode(config, forKey: .config)
        try container.encode(productAds, forKey: .productAds)
        try container.encode(relay, forKey: .relay)
        try container.encode(status, forKey: .status)
    }

    /// If true, enables for users the reporting feature for products back in stock.
     /// 
    public lazy var backInStockReporting: Bool = {
        self._variables.getBool("back_in_stock_reporting") ?? _defaults.backInStockReporting
    }()
    
    /// A Map of website configurations
     /// 
    public lazy var config: [String: WebsiteConfig] = {
        self._variables.getVariablesMap("config")?.mapValuesNotNull(WebsiteConfig.create).mergeWith(_defaults.config, WebsiteConfig.mergeWith) ?? _defaults.config
    }()
    
    /// If true, enables the product advertisement feature, allowing users to see
     /// and interact with ads for various products.
     /// 
    public lazy var productAds: Bool = {
        self._variables.getBool("product_ads") ?? _defaults.productAds
    }()
    
    /// Configurable relay URL for production environment
     /// 
    public lazy var relay: String = {
        self._variables.getString("relay") ?? _defaults.relay
    }()
    
    /// Whether the Fakespot feature is enabled or disabled
     /// 
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
    
}
extension Shopping2023: FMLFeatureInterface {}
/// A feature that extends splash screen duration, allowing additional data
 /// fetching time for the app's initial run.
 /// 
public class SplashScreen: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
        let maximumDurationMs: Int
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = true,
        maximumDurationMs: Int = 6000
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled,
            maximumDurationMs: maximumDurationMs))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
        case maximumDurationMs = "maximum_duration_ms"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
        try container.encode(maximumDurationMs, forKey: .maximumDurationMs)
    }

    /// If true, the feature is active.
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
    /// The maximum amount of time in milliseconds the splashscreen will be visible
     /// while waiting for initialization calls to complete.
     /// 
    public lazy var maximumDurationMs: Int = {
        self._variables.getInt("maximum_duration_ms") ?? _defaults.maximumDurationMs
    }()
    
}
extension SplashScreen: FMLFeatureInterface {}
/// Add pages as items findable with Spotlight.
public class SpotlightSearch: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
        let iconType: IconType?
        let keepForDays: Int?
        let searchableContent: PageContent?
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = true,
        iconType: IconType? = .screenshot,
        keepForDays: Int? = nil,
        searchableContent: PageContent? = .textExcerpt
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled,
            iconType: iconType,
            keepForDays: keepForDays,
            searchableContent: searchableContent))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
        case iconType = "icon-type"
        case keepForDays = "keep-for-days"
        case searchableContent = "searchable-content"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
        try container.encode(iconType?.rawValue, forKey: .iconType)
        try container.encode(keepForDays, forKey: .keepForDays)
        try container.encode(searchableContent?.rawValue, forKey: .searchableContent)
    }

    /// If this is true, then on each page load adds a new item to Spotlight.
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
    /// The icon that is displayed next to the item in the search results. If this
     /// is `null`, then no icon is displayed.
     /// 
    public lazy var iconType: IconType? = {
        self._variables.getString("icon-type")?.map(IconType.enumValue) ?? _defaults.iconType
    }()
    
    /// Number of days to keep the item before automatic deletion. If this is left
     /// `null`, then it is left to iOS's default.
     /// 
    public lazy var keepForDays: Int? = {
        self._variables.getInt("keep-for-days") ?? _defaults.keepForDays
    }()
    
    /// The text content that is made searchable. If this is `null` then no
     /// additional content is used, and only the title and URL will be used.
     /// 
    public lazy var searchableContent: PageContent? = {
        self._variables.getString("searchable-content")?.map(PageContent.enumValue) ?? _defaults.searchableContent
    }()
    
}
extension SpotlightSearch: FMLFeatureInterface {}
/// This feature is for managing the roll out of the Tab Tray refactor feature
 /// 
public class TabTrayRefactorFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
    }

    /// Enables the feature
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
}
extension TabTrayRefactorFeature: FMLFeatureInterface {}
/// The tab tray screen that the user goes to when they open the tab tray.
public class TabTrayFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let sectionsEnabled: [TabTraySection: Bool]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        sectionsEnabled: [TabTraySection: Bool] = [.inactiveTabs: true]
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            sectionsEnabled: sectionsEnabled))
    }

    enum CodingKeys: String, CodingKey {
        case sectionsEnabled = "sections-enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(sectionsEnabled.mapKeysNotNull { $0.rawValue }, forKey: .sectionsEnabled)
    }

    /// This property provides a lookup table of whether or not the given section
     /// should be enabled. If the section is enabled, it should be toggleable
     /// in the settings screen, and on by default.
    public lazy var sectionsEnabled: [TabTraySection: Bool] = {
        self._variables.getBoolMap("sections-enabled")?.mapKeysNotNull(TabTraySection.enumValue).mergeWith(_defaults.sectionsEnabled) ?? _defaults.sectionsEnabled
    }()
    
}
extension TabTrayFeature: FMLFeatureInterface {}
/// This feature is for managing the roll out of the Toolbar refactor feature
 /// 
public class ToolbarRefactorFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
        let navigationHint: Bool
        let oneTapNewTab: Bool
        let unifiedSearch: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = false,
        navigationHint: Bool = false,
        oneTapNewTab: Bool = false,
        unifiedSearch: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled,
            navigationHint: navigationHint,
            oneTapNewTab: oneTapNewTab,
            unifiedSearch: unifiedSearch))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
        case navigationHint = "navigation_hint"
        case oneTapNewTab = "one_tap_new_tab"
        case unifiedSearch = "unified_search"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
        try container.encode(navigationHint, forKey: .navigationHint)
        try container.encode(oneTapNewTab, forKey: .oneTapNewTab)
        try container.encode(unifiedSearch, forKey: .unifiedSearch)
    }

    /// Enables the feature
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
    /// If true, enables the navigation contextual hint.
     /// 
    public lazy var navigationHint: Bool = {
        self._variables.getBool("navigation_hint") ?? _defaults.navigationHint
    }()
    
    /// If true, enables the one tap new tab feature for users.
     /// 
    public lazy var oneTapNewTab: Bool = {
        self._variables.getBool("one_tap_new_tab") ?? _defaults.oneTapNewTab
    }()
    
    /// Enables the unified search feature
     /// 
    public lazy var unifiedSearch: Bool = {
        self._variables.getBool("unified_search") ?? _defaults.unifiedSearch
    }()
    
}
extension ToolbarRefactorFeature: FMLFeatureInterface {}
/// The Enhanced Tracking Protection refactor
 /// 
public class TrackingProtectionRefactor: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
    }

    /// Whether the Enhanced Tracking Protection refactor is enabled or not
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
}
extension TrackingProtectionRefactor: FMLFeatureInterface {}
/// The configuration for the status of the zoom feature
 /// 
public class ZoomFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let status: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        status: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            status: status))
    }

    enum CodingKeys: String, CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(status, forKey: .status)
    }

    /// Whether the page zoom feature is enabled or not
     /// 
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
    
}
extension ZoomFeature: FMLFeatureInterface {}


/// The identifiers for a individual contextual hints.
public enum ContextualHint: String, CaseIterable, Codable {
    
    /// The contextual hint bubble that appears to provide a hint about the toolbar.
    case toolbarHint = "toolbar-hint"
    

    public static func enumValue(_ s: String?) -> ContextualHint? {
        guard let s = s else {
            return nil
        }
        return ContextualHint(rawValue: s)
    }
}


/// The identifiers for the sections of the homescreen.
public enum HomeScreenSection: String, CaseIterable, Codable {
    
    /// The tabs the user was looking immediately before being interrupted.
    case jumpBackIn = "jump-back-in"
    
    /// The tab groups
    case recentExplorations = "recent-explorations"
    

    public static func enumValue(_ s: String?) -> HomeScreenSection? {
        guard let s = s else {
            return nil
        }
        return HomeScreenSection(rawValue: s)
    }
}


/// The icon that will be added to the item in the device's search engine.
public enum IconType: String, CaseIterable, Codable {
    
    /// The favicon of the page
    case favicon = "favicon"
    
    /// An icon generated from the first letter of the base domain.
    case letter = "letter"
    
    /// A screenshot of the page at load time.
    case screenshot = "screenshot"
    

    public static func enumValue(_ s: String?) -> IconType? {
        guard let s = s else {
            return nil
        }
        return IconType(rawValue: s)
    }
}


/// The identifiers for the different images available for cards in onboarding
 /// 
public enum NimbusOnboardingHeaderImage: String, CaseIterable, Codable {
    
    /// Corresponding to the fox window image
     /// 
    case customizeFirefox = "customize-firefox"
    
    /// Corresponding to the notifications image
     /// 
    case notifications = "notifications"
    
    /// Corresponding to the notifications image for CTD
     /// 
    case notificationsCtd = "notifications-ctd"
    
    /// Corresponding to the fox search widget image
     /// 
    case searchWidget = "search-widget"
    
    /// Corresponding to the set to default steps image
     /// 
    case setDefaultSteps = "set-default-steps"
    
    /// Corresponding to the set to dock image
     /// 
    case setToDock = "set-to-dock"
    
    /// Corresponding to the sync-devices image
     /// 
    case syncDevices = "sync-devices"
    
    /// Corresponding to the sync image for CTD
     /// 
    case syncDevicesCtd = "sync-devices-ctd"
    
    /// Corresponding to the fox world image
     /// 
    case themeing = "themeing"
    
    /// Corresponding to the fox world image
     /// 
    case toolbar = "toolbar"
    
    /// Corresponding to the welcome image for CTD
     /// 
    case welcomeCtd = "welcome-ctd"
    
    /// Corresponding to the fox world image
     /// 
    case welcomeGlobe = "welcome-globe"
    

    public static func enumValue(_ s: String?) -> NimbusOnboardingHeaderImage? {
        guard let s = s else {
            return nil
        }
        return NimbusOnboardingHeaderImage(rawValue: s)
    }
}


/// The identifiers for the different images available for multiple choice
 /// buttons in onboarding
 /// 
public enum NimbusOnboardingMultipleChoiceButtonImage: String, CaseIterable, Codable {
    
    /// Corresponding to the dark theme
     /// 
    case themeDark = "theme-dark"
    
    /// Corresponding to the light theme
     /// 
    case themeLight = "theme-light"
    
    /// Corresponding to the system theme
     /// 
    case themeSystem = "theme-system"
    
    /// Corresponding to the toolbar on the bottom
     /// 
    case toolbarBottom = "toolbar-bottom"
    
    /// Corresponding to the toolbar on top
     /// 
    case toolbarTop = "toolbar-top"
    

    public static func enumValue(_ s: String?) -> NimbusOnboardingMultipleChoiceButtonImage? {
        guard let s = s else {
            return nil
        }
        return NimbusOnboardingMultipleChoiceButtonImage(rawValue: s)
    }
}


/// The identifiers for the different actions available for cards in onboarding
 /// 
public enum OnboardingActions: String, CaseIterable, Codable {
    
    /// Will end the onboarding on a set card
     /// 
    case endOnboarding = "end-onboarding"
    
    /// Will take the user to the next card
     /// 
    case forwardOneCard = "forward-one-card"
    
    /// Will take the user to the next card
     /// 
    case forwardThreeCard = "forward-three-card"
    
    /// Will take the user to the next card
     /// 
    case forwardTwoCard = "forward-two-card"
    
    /// Will open up a popup with instructions for something
     /// 
    case openInstructionsPopup = "open-instructions-popup"
    
    /// Will take the user to the default browser settings in the iOS system
     /// settings
     /// 
    case openIosFxSettings = "open-ios-fx-settings"
    
    /// Will open a webview where the user can read the privacy policy
     /// 
    case readPrivacyPolicy = "read-privacy-policy"
    
    /// Will request to allow notifications from the user
     /// 
    case requestNotifications = "request-notifications"
    
    /// Will send the user to settings to set Firefox as their default browser and
     /// advance to next card
     /// 
    case setDefaultBrowser = "set-default-browser"
    
    /// Will take the user to the sync sign in flow
     /// 
    case syncSignIn = "sync-sign-in"
    

    public static func enumValue(_ s: String?) -> OnboardingActions? {
        guard let s = s else {
            return nil
        }
        return OnboardingActions(rawValue: s)
    }
}


/// The identifiers for the different types of onboarding cards.
 /// 
public enum OnboardingCardType: String, CaseIterable, Codable {
    
    /// Corresponding to basic info onboarding cards
     /// 
    case basic = "basic"
    
    /// Corresponding to onboarding cards with multiple choice buttons
     /// 
    case multipleChoice = "multiple-choice"
    

    public static func enumValue(_ s: String?) -> OnboardingCardType? {
        guard let s = s else {
            return nil
        }
        return OnboardingCardType(rawValue: s)
    }
}


/// The identifiers for the different actions available for the insturction card
 /// in onboarding
 /// 
public enum OnboardingInstructionsPopupActions: String, CaseIterable, Codable {
    
    /// Will dismiss the popup
     /// 
    case dismiss = "dismiss"
    
    /// Will dismiss the popup and move to the next card
     /// 
    case dismissAndNextCard = "dismiss-and-next-card"
    
    /// Will take the user to the default browser settings in the iOS system
     /// settings
     /// 
    case openIosFxSettings = "open-ios-fx-settings"
    

    public static func enumValue(_ s: String?) -> OnboardingInstructionsPopupActions? {
        guard let s = s else {
            return nil
        }
        return OnboardingInstructionsPopupActions(rawValue: s)
    }
}


/// The identifiers for the different actions available for cards in onboarding
 /// 
public enum OnboardingMultipleChoiceAction: String, CaseIterable, Codable {
    
    /// Will will set the theme to dark mode
     /// 
    case themeDark = "theme-dark"
    
    /// Will set the theme to light mode
     /// 
    case themeLight = "theme-light"
    
    /// Will set the theme to use the system theme
     /// 
    case themeSystemDefault = "theme-system-default"
    
    /// Will set the toolbar on the bottom
     /// 
    case toolbarBottom = "toolbar-bottom"
    
    /// Will set the toolbar on the top
     /// 
    case toolbarTop = "toolbar-top"
    

    public static func enumValue(_ s: String?) -> OnboardingMultipleChoiceAction? {
        guard let s = s else {
            return nil
        }
        return OnboardingMultipleChoiceAction(rawValue: s)
    }
}


/// The identifiers for the different types of onboarding cards.
 /// 
public enum OnboardingType: String, CaseIterable, Codable {
    
    /// Corresponding to onboarding cards that are for new users
     /// 
    case freshInstall = "fresh-install"
    
    /// Corresponding to onboarding cards that are for users who have updated
     /// 
    case upgrade = "upgrade"
    

    public static func enumValue(_ s: String?) -> OnboardingType? {
        guard let s = s else {
            return nil
        }
        return OnboardingType(rawValue: s)
    }
}


/// The page content that will be added as an item in the device's search
 /// engine.
public enum PageContent: String, CaseIterable, Codable {
    
    /// Use all the page as HTML
    case htmlContent = "html-content"
    
    /// Use all the page as text
    case textContent = "text-content"
    
    /// Only use the first paragraph
    case textExcerpt = "text-excerpt"
    

    public static func enumValue(_ s: String?) -> PageContent? {
        guard let s = s else {
            return nil
        }
        return PageContent(rawValue: s)
    }
}


/// The type of a Firefox Suggest search suggestion.
public enum SuggestionType: String, CaseIterable, Codable {
    
    /// A Firefox Suggestion for desktop from adMarketplace.
    case amp = "amp"
    
    /// A Firefox Suggestion specifically for mobile from adMarketplace.
    case ampMobile = "ampMobile"
    
    /// A Firefox Suggestion for a Wikipedia page.
    case wikipedia = "wikipedia"
    

    public static func enumValue(_ s: String?) -> SuggestionType? {
        guard let s = s else {
            return nil
        }
        return SuggestionType(rawValue: s)
    }
}


/// The identifiers for the sections of the tab tray.
public enum TabTraySection: String, CaseIterable, Codable {
    
    /// Tabs that have been automatically closed for the user.
    case inactiveTabs = "inactive-tabs"
    

    public static func enumValue(_ s: String?) -> TabTraySection? {
        guard let s = s else {
            return nil
        }
        return TabTraySection(rawValue: s)
    }
}

/// A configuration option for the awesome bar. Part of the `search` feature.
public class AwesomeBar: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let minSearchTerm: Int
        let position: SearchBarPositionFeature
        let searchHighlights: Bool
        let usePageContent: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        minSearchTerm: Int = 3,
        position: SearchBarPositionFeature = SearchBarPositionFeature(isBottom: true, isPositionFeatureEnabled: true, isToolbarCfrOn: true),
        searchHighlights: Bool = false,
        usePageContent: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            minSearchTerm: minSearchTerm,
            position: position,
            searchHighlights: searchHighlights,
            usePageContent: usePageContent))
    }

    enum CodingKeys: String, CodingKey {
        case minSearchTerm = "min-search-term"
        case position = "position"
        case searchHighlights = "search-highlights"
        case usePageContent = "use-page-content"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(minSearchTerm, forKey: .minSearchTerm)
        try container.encode(position, forKey: .position)
        try container.encode(searchHighlights, forKey: .searchHighlights)
        try container.encode(usePageContent, forKey: .usePageContent)
    }

    /// The minimum number of characters that the user types before searching in
     /// the page.
    public lazy var minSearchTerm: Int = {
        self._variables.getInt("min-search-term") ?? _defaults.minSearchTerm
    }()
    
    /// This property defines whether or not the feature is enabled, and the
     /// position of the search bar
     /// 
    public lazy var position: SearchBarPositionFeature = {
        self._variables.getVariables("position")?.map(SearchBarPositionFeature.create)._mergeWith(_defaults.position) ?? _defaults.position
    }()
    
    /// Whether or not search highlights are enabled
    public lazy var searchHighlights: Bool = {
        self._variables.getBool("search-highlights") ?? _defaults.searchHighlights
    }()
    
    /// Search in the open tab's text content when typing.
    public lazy var usePageContent: Bool = {
        self._variables.getBool("use-page-content") ?? _defaults.usePageContent
    }()
    
}

public extension AwesomeBar {
    func _mergeWith(_ defaults: AwesomeBar?) -> AwesomeBar {
        guard let defaults = defaults else {
            return self
        }
        return AwesomeBar(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> AwesomeBar {
        return AwesomeBar(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: AwesomeBar, _ defaults: AwesomeBar) -> AwesomeBar {
        return overrides._mergeWith(defaults)
    }
}

/// The configuration for the a feature that can be enabled or disabled
public class GeneralFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let status: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        status: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            status: status))
    }

    enum CodingKeys: String, CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(status, forKey: .status)
    }

    /// Whether or not the feature is enabled
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
    
}

public extension GeneralFeature {
    func _mergeWith(_ defaults: GeneralFeature?) -> GeneralFeature {
        guard let defaults = defaults else {
            return self
        }
        return GeneralFeature(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> GeneralFeature {
        return GeneralFeature(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: GeneralFeature, _ defaults: GeneralFeature) -> GeneralFeature {
        return overrides._mergeWith(defaults)
    }
}

/// A group of properties describing the attributes of a card.
 /// 
public class NimbusOnboardingButton: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let action: OnboardingActions
        let title: String
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        action: OnboardingActions = .forwardOneCard,
        title: String = ""
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            action: action,
            title: title))
    }

    enum CodingKeys: String, CodingKey {
        case action = "action"
        case title = "title"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(action.rawValue, forKey: .action)
        try container.encode(title, forKey: .title)
    }

    /// The action the button should take. The default for this will be "forward-
     /// one-card"
     /// 
    public lazy var action: OnboardingActions = {
        self._variables.getString("action")?.map(OnboardingActions.enumValue) ?? _defaults.action
    }()
    
    /// The text of the button title. This should never be defaulted.
     /// 
    public lazy var title: String = {
        self._variables.getText("title") ?? self._variables.resourceBundles.getString(named: _defaults.title) ?? _defaults.title
    }()
    
}

public extension NimbusOnboardingButton {
    func _mergeWith(_ defaults: NimbusOnboardingButton?) -> NimbusOnboardingButton {
        guard let defaults = defaults else {
            return self
        }
        return NimbusOnboardingButton(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> NimbusOnboardingButton {
        return NimbusOnboardingButton(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: NimbusOnboardingButton, _ defaults: NimbusOnboardingButton) -> NimbusOnboardingButton {
        return overrides._mergeWith(defaults)
    }
}

/// A set of buttons for the card. There can be up to two, but there must be at
 /// least one.
 /// 
public class NimbusOnboardingButtons: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let primary: NimbusOnboardingButton
        let secondary: NimbusOnboardingButton?
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        primary: NimbusOnboardingButton = NimbusOnboardingButton(action: .forwardOneCard, title: "Primary Button"),
        secondary: NimbusOnboardingButton? = nil
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            primary: primary,
            secondary: secondary))
    }

    enum CodingKeys: String, CodingKey {
        case primary = "primary"
        case secondary = "secondary"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(primary, forKey: .primary)
        try container.encode(secondary, forKey: .secondary)
    }

    /// The primary button for the card. This must exist.
     /// 
    public lazy var primary: NimbusOnboardingButton = {
        self._variables.getVariables("primary")?.map(NimbusOnboardingButton.create)._mergeWith(_defaults.primary) ?? _defaults.primary
    }()
    
    /// A secondary, optional, button for the card.
     /// 
    public lazy var secondary: NimbusOnboardingButton? = {
        self._variables.getVariables("secondary")?.map(NimbusOnboardingButton.create)._mergeWith(_defaults.secondary) ?? _defaults.secondary
    }()
    
}

public extension NimbusOnboardingButtons {
    func _mergeWith(_ defaults: NimbusOnboardingButtons?) -> NimbusOnboardingButtons {
        guard let defaults = defaults else {
            return self
        }
        return NimbusOnboardingButtons(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> NimbusOnboardingButtons {
        return NimbusOnboardingButtons(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: NimbusOnboardingButtons, _ defaults: NimbusOnboardingButtons) -> NimbusOnboardingButtons {
        return overrides._mergeWith(defaults)
    }
}

/// A group of properties describing the attributes of a card.
 /// 
public class NimbusOnboardingCardData: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let body: String
        let buttons: NimbusOnboardingButtons
        let cardType: OnboardingCardType
        let disqualifiers: [String]
        let image: NimbusOnboardingHeaderImage
        let instructionsPopup: NimbusOnboardingInstructionPopup?
        let link: NimbusOnboardingLink?
        let multipleChoiceButtons: [NimbusOnboardingMultipleChoiceButton]
        let onboardingType: OnboardingType
        let order: Int
        let prerequisites: [String]
        let title: String
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        body: String = "",
        buttons: NimbusOnboardingButtons = NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .forwardOneCard, title: "Onboarding/Onboarding.Sync.Skip.Action.v114"), secondary: nil),
        cardType: OnboardingCardType = .basic,
        disqualifiers: [String] = [],
        image: NimbusOnboardingHeaderImage = .welcomeGlobe,
        instructionsPopup: NimbusOnboardingInstructionPopup? = nil,
        link: NimbusOnboardingLink? = nil,
        multipleChoiceButtons: [NimbusOnboardingMultipleChoiceButton] = [],
        onboardingType: OnboardingType = .freshInstall,
        order: Int = 10,
        prerequisites: [String] = [],
        title: String = ""
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            body: body,
            buttons: buttons,
            cardType: cardType,
            disqualifiers: disqualifiers,
            image: image,
            instructionsPopup: instructionsPopup,
            link: link,
            multipleChoiceButtons: multipleChoiceButtons,
            onboardingType: onboardingType,
            order: order,
            prerequisites: prerequisites,
            title: title))
    }

    enum CodingKeys: String, CodingKey {
        case body = "body"
        case buttons = "buttons"
        case cardType = "card-type"
        case disqualifiers = "disqualifiers"
        case image = "image"
        case instructionsPopup = "instructions-popup"
        case link = "link"
        case multipleChoiceButtons = "multiple-choice-buttons"
        case onboardingType = "onboarding-type"
        case order = "order"
        case prerequisites = "prerequisites"
        case title = "title"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(body, forKey: .body)
        try container.encode(buttons, forKey: .buttons)
        try container.encode(cardType.rawValue, forKey: .cardType)
        try container.encode(disqualifiers, forKey: .disqualifiers)
        try container.encode(image.rawValue, forKey: .image)
        try container.encode(instructionsPopup, forKey: .instructionsPopup)
        try container.encode(link, forKey: .link)
        try container.encode(multipleChoiceButtons, forKey: .multipleChoiceButtons)
        try container.encode(onboardingType.rawValue, forKey: .onboardingType)
        try container.encode(order, forKey: .order)
        try container.encode(prerequisites, forKey: .prerequisites)
        try container.encode(title, forKey: .title)
    }

    /// The body text dispalyed on the card, in less prominent text. This should
     /// never be defaulted.
     /// 
    public lazy var body: String = {
        self._variables.getText("body") ?? self._variables.resourceBundles.getString(named: _defaults.body) ?? _defaults.body
    }()
    
    /// The set of buttons associated with the card.
     /// 
    public lazy var buttons: NimbusOnboardingButtons = {
        self._variables.getVariables("buttons")?.map(NimbusOnboardingButtons.create)._mergeWith(_defaults.buttons) ?? _defaults.buttons
    }()
    
    /// The type of onboarding this card should be shown in, whether it a fresh
     /// install or an update. The default is fresh-install.
     /// 
    public lazy var cardType: OnboardingCardType = {
        self._variables.getString("card-type")?.map(OnboardingCardType.enumValue) ?? _defaults.cardType
    }()
    
    /// A list of ConditionName strings corresponding to targeting expressions. The
     /// card will not be shown if any expression is `true`.
     /// 
    public lazy var disqualifiers: [String] = {
        self._variables.getStringList("disqualifiers") ?? _defaults.disqualifiers
    }()
    
    /// The image that should be dispalyed on the card.
     /// 
    public lazy var image: NimbusOnboardingHeaderImage = {
        self._variables.getString("image")?.map(NimbusOnboardingHeaderImage.enumValue) ?? _defaults.image
    }()
    
    /// The object describing the specific instruction popup button for a card. If
     /// left empty, the card will have no instruction popup information
     /// 
    public lazy var instructionsPopup: NimbusOnboardingInstructionPopup? = {
        self._variables.getVariables("instructions-popup")?.map(NimbusOnboardingInstructionPopup.create)._mergeWith(_defaults.instructionsPopup) ?? _defaults.instructionsPopup
    }()
    
    /// The object describing the link button for a card. If left empty, the card
     /// will have no link.
     /// 
    public lazy var link: NimbusOnboardingLink? = {
        self._variables.getVariables("link")?.map(NimbusOnboardingLink.create)._mergeWith(_defaults.link) ?? _defaults.link
    }()
    
    /// A list of multiple choice buttons that the card will display
     /// 
    public lazy var multipleChoiceButtons: [NimbusOnboardingMultipleChoiceButton] = {
        self._variables.getVariablesList("multiple-choice-buttons")?.mapNotNull(NimbusOnboardingMultipleChoiceButton.create) ?? _defaults.multipleChoiceButtons
    }()
    
    /// The type of onboarding this card should be shown in, whether it a fresh
     /// install or an update. The default is fresh-install.
     /// 
    public lazy var onboardingType: OnboardingType = {
        self._variables.getString("onboarding-type")?.map(OnboardingType.enumValue) ?? _defaults.onboardingType
    }()
    
    /// The place in the order where the card will be found. The feature layer will
     /// then sort the cards based on this field.
     /// 
    public lazy var order: Int = {
        self._variables.getInt("order") ?? _defaults.order
    }()
    
    /// A list of ConditionName strings corresponding to targeting expressions. The
     /// card will be shown if all expressions `true` and if no expressions in
     /// the `disqualifiers` table are true, or if the `disqualifiers` table
     /// is empty.
     /// 
    public lazy var prerequisites: [String] = {
        self._variables.getStringList("prerequisites") ?? _defaults.prerequisites
    }()
    
    /// The title displayed on the card, in prominent, bolded text. This should
     /// never be defaulted.
     /// 
    public lazy var title: String = {
        self._variables.getText("title") ?? self._variables.resourceBundles.getString(named: _defaults.title) ?? _defaults.title
    }()
    
}

public extension NimbusOnboardingCardData {
    func _mergeWith(_ defaults: NimbusOnboardingCardData?) -> NimbusOnboardingCardData {
        guard let defaults = defaults else {
            return self
        }
        return NimbusOnboardingCardData(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> NimbusOnboardingCardData {
        return NimbusOnboardingCardData(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: NimbusOnboardingCardData, _ defaults: NimbusOnboardingCardData) -> NimbusOnboardingCardData {
        return overrides._mergeWith(defaults)
    }
}

/// The object outlining the content of the instruction card.
 /// 
public class NimbusOnboardingInstructionPopup: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let buttonAction: OnboardingInstructionsPopupActions
        let buttonTitle: String
        let instructions: [String]
        let title: String
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        buttonAction: OnboardingInstructionsPopupActions = .dismissAndNextCard,
        buttonTitle: String = "",
        instructions: [String] = [],
        title: String = ""
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            buttonAction: buttonAction,
            buttonTitle: buttonTitle,
            instructions: instructions,
            title: title))
    }

    enum CodingKeys: String, CodingKey {
        case buttonAction = "button-action"
        case buttonTitle = "button-title"
        case instructions = "instructions"
        case title = "title"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(buttonAction.rawValue, forKey: .buttonAction)
        try container.encode(buttonTitle, forKey: .buttonTitle)
        try container.encode(instructions, forKey: .instructions)
        try container.encode(title, forKey: .title)
    }

    /// The action the button should have. Default is `dismiss-and-next-card`
     /// 
    public lazy var buttonAction: OnboardingInstructionsPopupActions = {
        self._variables.getString("button-action")?.map(OnboardingInstructionsPopupActions.enumValue) ?? _defaults.buttonAction
    }()
    
    /// The title the button should have. This should never be defaulted.
     /// 
    public lazy var buttonTitle: String = {
        self._variables.getText("button-title") ?? self._variables.resourceBundles.getString(named: _defaults.buttonTitle) ?? _defaults.buttonTitle
    }()
    
    /// A list of instructions, either as free text, or as Text identifiers.
     /// 
    public lazy var instructions: [String] = {
        self._variables.getTextList("instructions") ?? _defaults.instructions.map { self._variables.resourceBundles.getString(named: $0) ?? $0 }
    }()
    
    /// The text of the popup. This should never be defaulted.
     /// 
    public lazy var title: String = {
        self._variables.getText("title") ?? self._variables.resourceBundles.getString(named: _defaults.title) ?? _defaults.title
    }()
    
}

public extension NimbusOnboardingInstructionPopup {
    func _mergeWith(_ defaults: NimbusOnboardingInstructionPopup?) -> NimbusOnboardingInstructionPopup {
        guard let defaults = defaults else {
            return self
        }
        return NimbusOnboardingInstructionPopup(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> NimbusOnboardingInstructionPopup {
        return NimbusOnboardingInstructionPopup(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: NimbusOnboardingInstructionPopup, _ defaults: NimbusOnboardingInstructionPopup) -> NimbusOnboardingInstructionPopup {
        return overrides._mergeWith(defaults)
    }
}

/// A group of properties describing the attributes for the active link on
 /// a card
 /// 
public class NimbusOnboardingLink: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let title: String
        let url: String
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        title: String = "Onboarding/Onboarding.Welcome.Link.Action.v114",
        url: String = "https://www.mozilla.org/privacy/firefox/"
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            title: title,
            url: url))
    }

    enum CodingKeys: String, CodingKey {
        case title = "title"
        case url = "url"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(title, forKey: .title)
        try container.encode(url, forKey: .url)
    }

    /// The text of the link title.
     /// 
    public lazy var title: String = {
        self._variables.getText("title") ?? self._variables.resourceBundles.getString(named: _defaults.title) ?? _defaults.title
    }()
    
    /// The url that the link will lead to.
     /// 
    public lazy var url: String = {
        self._variables.getString("url") ?? _defaults.url
    }()
    
}

public extension NimbusOnboardingLink {
    func _mergeWith(_ defaults: NimbusOnboardingLink?) -> NimbusOnboardingLink {
        guard let defaults = defaults else {
            return self
        }
        return NimbusOnboardingLink(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> NimbusOnboardingLink {
        return NimbusOnboardingLink(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: NimbusOnboardingLink, _ defaults: NimbusOnboardingLink) -> NimbusOnboardingLink {
        return overrides._mergeWith(defaults)
    }
}

/// A group of properties describing the attributes of a multiple choice button
 /// on a card
 /// 
public class NimbusOnboardingMultipleChoiceButton: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let action: OnboardingMultipleChoiceAction
        let image: NimbusOnboardingMultipleChoiceButtonImage
        let title: String
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        action: OnboardingMultipleChoiceAction = .themeSystemDefault,
        image: NimbusOnboardingMultipleChoiceButtonImage = .themeSystem,
        title: String = ""
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            action: action,
            image: image,
            title: title))
    }

    enum CodingKeys: String, CodingKey {
        case action = "action"
        case image = "image"
        case title = "title"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(action.rawValue, forKey: .action)
        try container.encode(image.rawValue, forKey: .image)
        try container.encode(title, forKey: .title)
    }

    /// The action the button should take. The default for this will be "theme-
     /// system-default"
     /// 
    public lazy var action: OnboardingMultipleChoiceAction = {
        self._variables.getString("action")?.map(OnboardingMultipleChoiceAction.enumValue) ?? _defaults.action
    }()
    
    /// The text of the button title. This should never be defaulted.
     /// 
    public lazy var image: NimbusOnboardingMultipleChoiceButtonImage = {
        self._variables.getString("image")?.map(NimbusOnboardingMultipleChoiceButtonImage.enumValue) ?? _defaults.image
    }()
    
    /// The text of the button title. This should never be defaulted.
     /// 
    public lazy var title: String = {
        self._variables.getText("title") ?? self._variables.resourceBundles.getString(named: _defaults.title) ?? _defaults.title
    }()
    
}

public extension NimbusOnboardingMultipleChoiceButton {
    func _mergeWith(_ defaults: NimbusOnboardingMultipleChoiceButton?) -> NimbusOnboardingMultipleChoiceButton {
        guard let defaults = defaults else {
            return self
        }
        return NimbusOnboardingMultipleChoiceButton(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> NimbusOnboardingMultipleChoiceButton {
        return NimbusOnboardingMultipleChoiceButton(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: NimbusOnboardingMultipleChoiceButton, _ defaults: NimbusOnboardingMultipleChoiceButton) -> NimbusOnboardingMultipleChoiceButton {
        return overrides._mergeWith(defaults)
    }
}

/// The configuration for the bottom search bar on the homescreen
public class SearchBarPositionFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let isBottom: Bool
        let isPositionFeatureEnabled: Bool
        let isToolbarCfrOn: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        isBottom: Bool = true,
        isPositionFeatureEnabled: Bool = true,
        isToolbarCfrOn: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            isBottom: isBottom,
            isPositionFeatureEnabled: isPositionFeatureEnabled,
            isToolbarCfrOn: isToolbarCfrOn))
    }

    enum CodingKeys: String, CodingKey {
        case isBottom = "is-bottom"
        case isPositionFeatureEnabled = "is-position-feature-enabled"
        case isToolbarCfrOn = "is-toolbar-cfr-on"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(isBottom, forKey: .isBottom)
        try container.encode(isPositionFeatureEnabled, forKey: .isPositionFeatureEnabled)
        try container.encode(isToolbarCfrOn, forKey: .isToolbarCfrOn)
    }

    /// Whether or not the default position is at the bottom
    public lazy var isBottom: Bool = {
        self._variables.getBool("is-bottom") ?? _defaults.isBottom
    }()
    
    /// Whether or not the feature is enabled
    public lazy var isPositionFeatureEnabled: Bool = {
        self._variables.getBool("is-position-feature-enabled") ?? _defaults.isPositionFeatureEnabled
    }()
    
    /// Whether or not the toolbar CFR shows. This is a temporary hack for Nimbus
    public lazy var isToolbarCfrOn: Bool = {
        self._variables.getBool("is-toolbar-cfr-on") ?? _defaults.isToolbarCfrOn
    }()
    
}

public extension SearchBarPositionFeature {
    func _mergeWith(_ defaults: SearchBarPositionFeature?) -> SearchBarPositionFeature {
        guard let defaults = defaults else {
            return self
        }
        return SearchBarPositionFeature(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> SearchBarPositionFeature {
        return SearchBarPositionFeature(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: SearchBarPositionFeature, _ defaults: SearchBarPositionFeature) -> SearchBarPositionFeature {
        return overrides._mergeWith(defaults)
    }
}

/// It represents a configuration for different e-commerce websites and includes
 /// regular expressions for extracting product IDs from their respective URLs
 /// 
public class WebsiteConfig: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let productIdFromUrlRegex: String
        let validTlDs: [String]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        productIdFromUrlRegex: String = "",
        validTlDs: [String] = []
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            productIdFromUrlRegex: productIdFromUrlRegex,
            validTlDs: validTlDs))
    }

    enum CodingKeys: String, CodingKey {
        case productIdFromUrlRegex = "productIdFromURLRegex"
        case validTlDs = "validTLDs"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(productIdFromUrlRegex, forKey: .productIdFromUrlRegex)
        try container.encode(validTlDs, forKey: .validTlDs)
    }

    /// It represents the product ID extracted from a regex query
     /// 
    public lazy var productIdFromUrlRegex: String = {
        self._variables.getString("productIdFromURLRegex") ?? _defaults.productIdFromUrlRegex
    }()
    
    /// Valid Top Level Domains
     /// 
    public lazy var validTlDs: [String] = {
        self._variables.getStringList("validTLDs") ?? _defaults.validTlDs
    }()
    
}

public extension WebsiteConfig {
    func _mergeWith(_ defaults: WebsiteConfig?) -> WebsiteConfig {
        guard let defaults = defaults else {
            return self
        }
        return WebsiteConfig(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> WebsiteConfig {
        return WebsiteConfig(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: WebsiteConfig, _ defaults: WebsiteConfig) -> WebsiteConfig {
        return overrides._mergeWith(defaults)
    }
}

