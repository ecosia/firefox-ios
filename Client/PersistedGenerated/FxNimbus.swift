// This file was autogenerated by the `nimbus-fml` crate.
// Trust me, you don't want to mess with it!
#if canImport(Foundation)
    import Foundation
#endif
#if canImport(MozillaAppServices)
    import MozillaAppServices
#endif

///
/// An object for safely accessing feature configuration from Nimbus.
///
/// This is generated.
public class FxNimbus : FeatureManifestInterface {
    public typealias Features = FxNimbusFeatures

    ///
    /// This should be populated at app launch; this method of initializing features
    /// will be removed in favor of the `initialize` function.
    ///
    public var api: FeaturesInterface?

    ///
    /// This method should be called as early in the startup sequence of the app as possible.
    /// This is to connect the Nimbus SDK (and thus server) with the `FxNimbus`
    /// class.
    ///
    /// The lambda MUST be threadsafe in its own right.
    public func initialize(with getSdk: @escaping () -> FeaturesInterface?) {
        self.getSdk = getSdk
        self.features.addressAutofillFeature.with(sdk: getSdk)
        self.features.contextualHintFeature.with(sdk: getSdk)
        self.features.creditCardAutofill.with(sdk: getSdk)
        self.features.feltPrivacyFeature.with(sdk: getSdk)
        self.features.firefoxSuggestFeature.with(sdk: getSdk)
        self.features.generalAppFeatures.with(sdk: getSdk)
        self.features.homescreenFeature.with(sdk: getSdk)
        self.features.messaging.with(sdk: getSdk)
        self.features.onboardingFrameworkFeature.with(sdk: getSdk)
        self.features.qrCodeCoordinatorRefactor.with(sdk: getSdk)
        self.features.search.with(sdk: getSdk)
        self.features.searchTermGroupsFeature.with(sdk: getSdk)
        self.features.shareSheet.with(sdk: getSdk)
        self.features.shopping2023.with(sdk: getSdk)
        self.features.spotlightSearch.with(sdk: getSdk)
        self.features.tabTrayRefactorFeature.with(sdk: getSdk)
        self.features.tabTrayFeature.with(sdk: getSdk)
        self.features.wallpaperFeature.with(sdk: getSdk)
        self.features.zoomFeature.with(sdk: getSdk)
        self.reinitialize()
    }

    fileprivate lazy var getSdk: GetSdk = { [self] in self.api }

    ///
    /// Represents all the features supported by Nimbus
    ///
    public let features = Features()

    public func getCoenrollingFeatureIds() -> [String] {
        ["messaging"]
    }

    /// Introspection utility method.
    public func getFeature(featureId: String) -> FeatureHolderAny? {
        switch featureId {
            case "address-autofill-feature": return FeatureHolderAny(wrapping: features.addressAutofillFeature)
            case "contextual-hint-feature": return FeatureHolderAny(wrapping: features.contextualHintFeature)
            case "credit-card-autofill": return FeatureHolderAny(wrapping: features.creditCardAutofill)
            case "felt-privacy-feature": return FeatureHolderAny(wrapping: features.feltPrivacyFeature)
            case "firefox-suggest-feature": return FeatureHolderAny(wrapping: features.firefoxSuggestFeature)
            case "general-app-features": return FeatureHolderAny(wrapping: features.generalAppFeatures)
            case "homescreenFeature": return FeatureHolderAny(wrapping: features.homescreenFeature)
            case "messaging": return FeatureHolderAny(wrapping: features.messaging)
            case "onboarding-framework-feature": return FeatureHolderAny(wrapping: features.onboardingFrameworkFeature)
            case "qr-code-coordinator-refactor": return FeatureHolderAny(wrapping: features.qrCodeCoordinatorRefactor)
            case "search": return FeatureHolderAny(wrapping: features.search)
            case "search-term-groups-feature": return FeatureHolderAny(wrapping: features.searchTermGroupsFeature)
            case "share-sheet": return FeatureHolderAny(wrapping: features.shareSheet)
            case "shopping2023": return FeatureHolderAny(wrapping: features.shopping2023)
            case "spotlight-search": return FeatureHolderAny(wrapping: features.spotlightSearch)
            case "tab-tray-refactor-feature": return FeatureHolderAny(wrapping: features.tabTrayRefactorFeature)
            case "tabTrayFeature": return FeatureHolderAny(wrapping: features.tabTrayFeature)
            case "wallpaper-feature": return FeatureHolderAny(wrapping: features.wallpaperFeature)
            case "zoom-feature": return FeatureHolderAny(wrapping: features.zoomFeature)
            default: return nil
        }
    }

    ///
    /// All generated initialization code. Clients shouldn't need to override or call
    /// this.
    /// We put it in a separate method because we have to be quite careful about what order
    /// the initialization happens inâ€” e.g. when importing other FML files.
    ///
    private func reinitialize() {
        // Nothing left to do.
    }

    ///
    /// Refresh the cache of configuration objects.
    ///
    /// For performance reasons, the feature configurations are constructed once then cached.
    /// This method is to clear that cache for all features configured with Nimbus.
    ///
    /// It must be called whenever the Nimbus SDK finishes the `applyPendingExperiments()` method.
    ///
    public func invalidateCachedValues() {
        features.addressAutofillFeature.with(cachedValue: nil)
        features.contextualHintFeature.with(cachedValue: nil)
        features.creditCardAutofill.with(cachedValue: nil)
        features.feltPrivacyFeature.with(cachedValue: nil)
        features.firefoxSuggestFeature.with(cachedValue: nil)
        features.generalAppFeatures.with(cachedValue: nil)
        features.homescreenFeature.with(cachedValue: nil)
        features.messaging.with(cachedValue: nil)
        features.onboardingFrameworkFeature.with(cachedValue: nil)
        features.qrCodeCoordinatorRefactor.with(cachedValue: nil)
        features.search.with(cachedValue: nil)
        features.searchTermGroupsFeature.with(cachedValue: nil)
        features.shareSheet.with(cachedValue: nil)
        features.shopping2023.with(cachedValue: nil)
        features.spotlightSearch.with(cachedValue: nil)
        features.tabTrayRefactorFeature.with(cachedValue: nil)
        features.tabTrayFeature.with(cachedValue: nil)
        features.wallpaperFeature.with(cachedValue: nil)
        features.zoomFeature.with(cachedValue: nil)
    }

    ///
    /// A singleton instance of FxNimbus
    ///
    public static let shared = FxNimbus()
}

public class FxNimbusFeatures {
    /// This property defines the address card autofill feature
    public lazy var addressAutofillFeature: FeatureHolder<AddressAutofillFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "address-autofill-feature") { variables, prefs in
            AddressAutofillFeature(variables, prefs)
        }
    }()
    /// This set holds all features pertaining to contextual hints.
    public lazy var contextualHintFeature: FeatureHolder<ContextualHintFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "contextual-hint-feature") { variables, prefs in
            ContextualHintFeature(variables, prefs)
        }
    }()
    /// This property defines the credit card autofill feature
    public lazy var creditCardAutofill: FeatureHolder<CreditCardAutofill> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "credit-card-autofill") { variables, prefs in
            CreditCardAutofill(variables, prefs)
        }
    }()
    /// The feature that enhances private browsing mode
    public lazy var feltPrivacyFeature: FeatureHolder<FeltPrivacyFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "felt-privacy-feature") { variables, prefs in
            FeltPrivacyFeature(variables, prefs)
        }
    }()
    /// Configuration for the Firefox Suggest feature.
    public lazy var firefoxSuggestFeature: FeatureHolder<FirefoxSuggestFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "firefox-suggest-feature") { variables, prefs in
            FirefoxSuggestFeature(variables, prefs)
        }
    }()
    /// The feature that contains feature flags for the entire application
    public lazy var generalAppFeatures: FeatureHolder<GeneralAppFeatures> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "general-app-features") { variables, prefs in
            GeneralAppFeatures(variables, prefs)
        }
    }()
    /// The homescreen that the user goes to when they press home or new tab.
    public lazy var homescreenFeature: FeatureHolder<HomescreenFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "homescreenFeature") { variables, prefs in
            HomescreenFeature(variables, prefs)
        }
    }()
    /// The in-app messaging system
         /// 
    public lazy var messaging: FeatureHolder<Messaging> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "messaging") { variables, prefs in
            Messaging(variables, prefs)
        }
    }()
    /// The new onboarding framework feature that will allow onboarding to be
         /// experimentable through initial experiments.
         /// 
    public lazy var onboardingFrameworkFeature: FeatureHolder<OnboardingFrameworkFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "onboarding-framework-feature") { variables, prefs in
            OnboardingFrameworkFeature(variables, prefs)
        }
    }()
    /// The feature for managing the roll out of the qrCode coordinator.
         /// 
    public lazy var qrCodeCoordinatorRefactor: FeatureHolder<QrCodeCoordinatorRefactor> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "qr-code-coordinator-refactor") { variables, prefs in
            QrCodeCoordinatorRefactor(variables, prefs)
        }
    }()
    /// Configuring the functionality to do with search. This will be separated into
         /// smaller sub-features in later releases.
         /// 
    public lazy var search: FeatureHolder<Search> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "search") { variables, prefs in
            Search(variables, prefs)
        }
    }()
    /// The feature that controls whether or not search term groups are enabled.
    public lazy var searchTermGroupsFeature: FeatureHolder<SearchTermGroupsFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "search-term-groups-feature") { variables, prefs in
            SearchTermGroupsFeature(variables, prefs)
        }
    }()
    /// This feature define the redesign of the share sheet
    public lazy var shareSheet: FeatureHolder<ShareSheet> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "share-sheet") { variables, prefs in
            ShareSheet(variables, prefs)
        }
    }()
    /// The configuration setting for the status of the Fakespot feature
         /// 
    public lazy var shopping2023: FeatureHolder<Shopping2023> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "shopping2023") { variables, prefs in
            Shopping2023(variables, prefs)
        }
    }()
    /// Add pages as items findable with Spotlight.
    public lazy var spotlightSearch: FeatureHolder<SpotlightSearch> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "spotlight-search") { variables, prefs in
            SpotlightSearch(variables, prefs)
        }
    }()
    /// This feature is for managing the roll out of the Tab Tray refactor feature
         /// 
    public lazy var tabTrayRefactorFeature: FeatureHolder<TabTrayRefactorFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "tab-tray-refactor-feature") { variables, prefs in
            TabTrayRefactorFeature(variables, prefs)
        }
    }()
    /// The tab tray screen that the user goes to when they open the tab tray.
    public lazy var tabTrayFeature: FeatureHolder<TabTrayFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "tabTrayFeature") { variables, prefs in
            TabTrayFeature(variables, prefs)
        }
    }()
    /// This property defines the configuration for the wallpaper feature
    public lazy var wallpaperFeature: FeatureHolder<WallpaperFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "wallpaper-feature") { variables, prefs in
            WallpaperFeature(variables, prefs)
        }
    }()
    /// The configuration for the status of the zoom feature
         /// 
    public lazy var zoomFeature: FeatureHolder<ZoomFeature> = {
        FeatureHolder(FxNimbus.shared.getSdk, featureId: "zoom-feature") { variables, prefs in
            ZoomFeature(variables, prefs)
        }
    }()
}

// Public interface members begin here.

/// This property defines the address card autofill feature
public class AddressAutofillFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let status: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        status: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            status: status))
    }

    enum CodingKeys: String, CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(status, forKey: .status)
    }

    /// If true, we will allow user to use the address autofill feature
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
    
}
extension AddressAutofillFeature: FMLFeatureInterface {}
/// This set holds all features pertaining to contextual hints.
public class ContextualHintFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let featuresEnabled: [ContextualHint: Bool]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        featuresEnabled: [ContextualHint: Bool] = [.toolbarHint: true]
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            featuresEnabled: featuresEnabled))
    }

    enum CodingKeys: String, CodingKey {
        case featuresEnabled = "features-enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(featuresEnabled.mapKeysNotNull { $0.rawValue }, forKey: .featuresEnabled)
    }

    /// This property provides a lookup table of whether specific contextual hints
     /// are enabled.
     /// 
    public lazy var featuresEnabled: [ContextualHint: Bool] = {
        self._variables.getBoolMap("features-enabled")?.mapKeysNotNull(ContextualHint.enumValue).mergeWith(_defaults.featuresEnabled) ?? _defaults.featuresEnabled
    }()
    
}
extension ContextualHintFeature: FMLFeatureInterface {}
/// This property defines the credit card autofill feature
public class CreditCardAutofill: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let creditCardAutofillStatus: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        creditCardAutofillStatus: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            creditCardAutofillStatus: creditCardAutofillStatus))
    }

    enum CodingKeys: String, CodingKey {
        case creditCardAutofillStatus = "credit-card-autofill-status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(creditCardAutofillStatus, forKey: .creditCardAutofillStatus)
    }

    /// If true, we will allow user to use the credit autofill feature
    public lazy var creditCardAutofillStatus: Bool = {
        self._variables.getBool("credit-card-autofill-status") ?? _defaults.creditCardAutofillStatus
    }()
    
}
extension CreditCardAutofill: FMLFeatureInterface {}
/// The feature that enhances private browsing mode
public class FeltPrivacyFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let feltDeletionEnabled: Bool
        let simplifiedUiEnabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        feltDeletionEnabled: Bool = false,
        simplifiedUiEnabled: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            feltDeletionEnabled: feltDeletionEnabled,
            simplifiedUiEnabled: simplifiedUiEnabled))
    }

    enum CodingKeys: String, CodingKey {
        case feltDeletionEnabled = "felt-deletion-enabled"
        case simplifiedUiEnabled = "simplified-ui-enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(feltDeletionEnabled, forKey: .feltDeletionEnabled)
        try container.encode(simplifiedUiEnabled, forKey: .simplifiedUiEnabled)
    }

    /// If true, enable Felt Deletion part of Felt Privacy
    public lazy var feltDeletionEnabled: Bool = {
        self._variables.getBool("felt-deletion-enabled") ?? _defaults.feltDeletionEnabled
    }()
    
    /// If true, enable simplified UI part of Felt Privacy
    public lazy var simplifiedUiEnabled: Bool = {
        self._variables.getBool("simplified-ui-enabled") ?? _defaults.simplifiedUiEnabled
    }()
    
}
extension FeltPrivacyFeature: FMLFeatureInterface {}
/// Configuration for the Firefox Suggest feature.
public class FirefoxSuggestFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let status: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        status: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            status: status))
    }

    enum CodingKeys: String, CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(status, forKey: .status)
    }

    /// Whether the feature is enabled. When Firefox Suggest is enabled, Firefox
     /// will download and store new search suggestions in the background, and
     /// show additional Search settings to control which suggestions appear
     /// in the awesomebar. When Firefox Suggest is disabled, Firefox will not
     /// download new suggestions, and hide the additional Search settings.
     /// 
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
    
}
extension FirefoxSuggestFeature: FMLFeatureInterface {}
/// The feature that contains feature flags for the entire application
public class GeneralAppFeatures: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let reportSiteIssue: GeneralFeature
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        reportSiteIssue: GeneralFeature = GeneralFeature(status: true)
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            reportSiteIssue: reportSiteIssue))
    }

    enum CodingKeys: String, CodingKey {
        case reportSiteIssue = "report-site-issue"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(reportSiteIssue, forKey: .reportSiteIssue)
    }

    /// This property defines whether or not the feature is enabled
    public lazy var reportSiteIssue: GeneralFeature = {
        self._variables.getVariables("report-site-issue")?.map(GeneralFeature.create)._mergeWith(_defaults.reportSiteIssue) ?? _defaults.reportSiteIssue
    }()
    
}
extension GeneralAppFeatures: FMLFeatureInterface {}
/// The homescreen that the user goes to when they press home or new tab.
public class HomescreenFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let pocketSponsoredStories: Bool
        let preferSwitchToOpenTab: Bool
        let sectionsEnabled: [HomeScreenSection: Bool]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        pocketSponsoredStories: Bool = true,
        preferSwitchToOpenTab: Bool = true,
        sectionsEnabled: [HomeScreenSection: Bool] = [.jumpBackIn: true, .recentExplorations: false]
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            pocketSponsoredStories: pocketSponsoredStories,
            preferSwitchToOpenTab: preferSwitchToOpenTab,
            sectionsEnabled: sectionsEnabled))
    }

    enum CodingKeys: String, CodingKey {
        case pocketSponsoredStories = "pocket-sponsored-stories"
        case preferSwitchToOpenTab = "prefer-switch-to-open-tab"
        case sectionsEnabled = "sections-enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(pocketSponsoredStories, forKey: .pocketSponsoredStories)
        try container.encode(preferSwitchToOpenTab, forKey: .preferSwitchToOpenTab)
        try container.encode(sectionsEnabled.mapKeysNotNull { $0.rawValue }, forKey: .sectionsEnabled)
    }

    /// This property defines whether pocket sponsored stories appear on the
     /// homepage.
     /// 
    public lazy var pocketSponsoredStories: Bool = {
        self._variables.getBool("pocket-sponsored-stories") ?? _defaults.pocketSponsoredStories
    }()
    
    /// Enables the feature to automatically switch to an existing tab with the same
     /// content instead of opening a new one.
     /// 
    public lazy var preferSwitchToOpenTab: Bool = {
        self._variables.getBool("prefer-switch-to-open-tab") ?? _defaults.preferSwitchToOpenTab
    }()
    
    /// This property provides a lookup table of whether or not the given section
     /// should be enabled. If the section is enabled, it should be toggleable
     /// in the settings screen, and on by default.
     /// 
    public lazy var sectionsEnabled: [HomeScreenSection: Bool] = {
        self._variables.getBoolMap("sections-enabled")?.mapKeysNotNull(HomeScreenSection.enumValue).mergeWith(_defaults.sectionsEnabled) ?? _defaults.sectionsEnabled
    }()
    
}
extension HomescreenFeature: FMLFeatureInterface {}
/// The in-app messaging system
 /// 
public class Messaging: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let experiment: String
        let actions: [String: String]
        let messageUnderExperiment: String?
        let messages: [String: MessageData]
        let onControl: ControlMessageBehavior
        let styles: [String: StyleData]
        let triggers: [String: String]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        experiment: String = "{experiment}",
        actions: [String: String] = ["ENABLE_PRIVATE_BROWSING": "://deep-link?url=homepanel/new-private-tab", "MAKE_DEFAULT_BROWSER": "://deep-link?url=default-browser/system-settings", "MAKE_DEFAULT_BROWSER_WITH_TUTORIAL": "://deep-link?url=default-browser/tutorial", "OPEN_NEW_TAB": "://deep-link?url=homepanel/new-tab", "OPEN_SETTINGS": "://deep-link?url=settings/general", "OPEN_SETTINGS_EMAIL": "://deep-link?url=settings/mailto", "OPEN_SETTINGS_FXA": "://deep-link?url=settings/fxa", "OPEN_SETTINGS_HOMESCREEN": "://deep-link?url=settings/homepage", "OPEN_SETTINGS_NEW_TAB": "://deep-link?url=settings/newtab", "OPEN_SETTINGS_PRIVACY": "://deep-link?url=settings/clear-private-data", "OPEN_SETTINGS_SEARCH_ENGINE": "://deep-link?url=settings/search", "OPEN_SETTINGS_THEME": "://deep-link?url=settings/theme", "OPEN_SETTINGS_WALLPAPERS": "://deep-link?url=settings/wallpaper", "VIEW_BOOKMARKS": "://deep-link?url=homepanel/bookmarks", "VIEW_DOWNLOADS": "://deep-link?url=homepanel/downloads", "VIEW_HISTORY": "://deep-link?url=homepanel/history", "VIEW_READING_LIST": "://deep-link?url=homepanel/reading-list", "VIEW_TOP_SITES": "://deep-link?url=homepanel/top-sites"],
        messageUnderExperiment: String? = nil,
        messages: [String: MessageData] = ["default-browser": MessageData(action: "MAKE_DEFAULT_BROWSER_WITH_TUTORIAL", buttonLabel: "Default Browser/DefaultBrowserCard.Button.v2", style: "FALLBACK", surface: .newTabCard, text: "Default Browser/DefaultBrowserCard.Description", title: "Default Browser/DefaultBrowserCard.Title", trigger: ["I_AM_NOT_DEFAULT_BROWSER", "SUPPORTS_DEFAULT_BROWSER", "ON_FOURTH_LAUNCH_THIS_YEAR"]), "survey-surface-message": MessageData(action: "https://www.macrumors.com", buttonLabel: "ResearchSurface/PrimaryButton.Label.v112", style: "SURVEY", surface: .survey, text: "ResearchSurface/Body.Text.v112", trigger: ["NEVER"])],
        onControl: ControlMessageBehavior = .showNextMessage,
        styles: [String: StyleData] = ["DEFAULT": StyleData(maxDisplayCount: 5, priority: 50), "FALLBACK": StyleData(maxDisplayCount: 20, priority: 40), "NOTIFICATION": StyleData(maxDisplayCount: 1, priority: 50), "PERSISTENT": StyleData(maxDisplayCount: 20, priority: 50), "SURVEY": StyleData(maxDisplayCount: 10, priority: 55), "URGENT": StyleData(maxDisplayCount: 10, priority: 100), "WARNING": StyleData(maxDisplayCount: 10, priority: 60)],
        triggers: [String: String] = ["AFTER_THREE_LAUNCHES_THIS_WEEK": "'app_cycle.foreground'|eventSum('Weeks', 1, 0) >= 3", "ALLOWED_TIPS_NOTIFICATIONS": "allowed_tips_notifications", "ALWAYS": "true", "DAY_3_AFTER_INSTALL": "days_since_install >= 3", "DEVICE_ANDROID": "os == 'Android'", "DEVICE_IOS": "os == 'iOS'", "INACTIVE_NEW_USER": "is_inactive_new_user", "I_AM_DEFAULT_BROWSER": "is_default_browser", "I_AM_NOT_DEFAULT_BROWSER": "is_default_browser == false", "MORE_THAN_24H_SINCE_INSTALLED_OR_UPDATED": "days_since_update >= 1", "NEVER": "false", "NOT_INSTALLED_TODAY": "days_since_install > 0", "NOT_LAUNCHED_YESTERDAY": "'app_cycle.foreground'|eventLastSeen('Days', 1) > 1", "ON_FOURTH_LAUNCH_THIS_YEAR": "'app_cycle.foreground'|eventSum('Years', 1, 0) > 3", "SUPPORTS_DEFAULT_BROWSER": "os_version|versionCompare('14.!') >= 0", "USER_DE_SPEAKER": "'de' in locale", "USER_EN_SPEAKER": "'en' in locale", "USER_FR_SPEAKER": "'fr' in locale", "USER_RECENTLY_INSTALLED": "days_since_install < 7", "USER_RECENTLY_UPDATED": "days_since_update < 7 && days_since_install != days_since_update", "USER_TIER_ONE_COUNTRY": "('US' in locale || 'GB' in locale || 'CA' in locale || 'DE' in locale || 'FR' in locale)"]
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            experiment: experiment,
            actions: actions,
            messageUnderExperiment: messageUnderExperiment,
            messages: messages,
            onControl: onControl,
            styles: styles,
            triggers: triggers))
    }

    enum CodingKeys: String, CodingKey {
        case experiment = "$$experiment:"
        case actions = "actions"
        case messageUnderExperiment = "message-under-experiment"
        case messages = "messages"
        case onControl = "on-control"
        case styles = "styles"
        case triggers = "triggers"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(experiment, forKey: .experiment)
        try container.encode(actions, forKey: .actions)
        try container.encode(messageUnderExperiment, forKey: .messageUnderExperiment)
        try container.encode(messages, forKey: .messages)
        try container.encode(onControl.rawValue, forKey: .onControl)
        try container.encode(styles, forKey: .styles)
        try container.encode(triggers, forKey: .triggers)
    }

    /// Not to be set by experiment.
    public lazy var experiment: String = {
        self._variables.getString("$$experiment:") ?? _defaults.experiment
    }()
    
    /// A growable map of action URLs.
    public lazy var actions: [String: String] = {
        self._variables.getStringMap("actions")?.mergeWith(_defaults.actions) ?? _defaults.actions
    }()
    
    /// Deprecated. Please use "experiment": "{experiment}" instead.
    public lazy var messageUnderExperiment: String? = {
        self._variables.getString("message-under-experiment") ?? _defaults.messageUnderExperiment
    }()
    
    /// A growable collection of messages, where the Key is the message identifier
     /// and the value is its associated MessageData.
     /// 
    public lazy var messages: [String: MessageData] = {
        self._variables.getVariablesMap("messages")?.mapValuesNotNull(MessageData.create).mergeWith(_defaults.messages, MessageData.mergeWith) ?? _defaults.messages
    }()
    
    /// What should be displayed when a control message is selected.
    public lazy var onControl: ControlMessageBehavior = {
        self._variables.getString("on-control")?.map(ControlMessageBehavior.enumValue) ?? _defaults.onControl
    }()
    
    /// A map of styles to configure message appearance.
     /// 
    public lazy var styles: [String: StyleData] = {
        self._variables.getVariablesMap("styles")?.mapValuesNotNull(StyleData.create).mergeWith(_defaults.styles, StyleData.mergeWith) ?? _defaults.styles
    }()
    
    /// A collection of out the box trigger expressions. Each entry maps to a valid
     /// JEXL expression.
     /// 
    public lazy var triggers: [String: String] = {
        self._variables.getStringMap("triggers")?.mergeWith(_defaults.triggers) ?? _defaults.triggers
    }()
    
}
extension Messaging: FMLFeatureInterface {}
/// The new onboarding framework feature that will allow onboarding to be
 /// experimentable through initial experiments.
 /// 
public class OnboardingFrameworkFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let cards: [String: NimbusOnboardingCardData]
        let conditions: [String: String]
        let dismissable: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        cards: [String: NimbusOnboardingCardData] = ["notification-permissions": NimbusOnboardingCardData(body: "Onboarding/Onboarding.Notification.Description.v120", buttons: NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .requestNotifications, title: "Onboarding/Onboarding.Notification.TurnOnNotifications.Action.v114"), secondary: NimbusOnboardingButton(action: .nextCard, title: "Onboarding/Onboarding.Notification.Skip.Action.v115")), image: .notifications, order: 30, prerequisites: ["ALWAYS"], title: "Onboarding/Onboarding.Notification.Title.v120", type: .freshInstall), "sign-to-sync": NimbusOnboardingCardData(body: "Onboarding/Onboarding.Sync.Description.v120", buttons: NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .syncSignIn, title: "Onboarding/Onboarding.Sync.SignIn.Action.v114"), secondary: NimbusOnboardingButton(action: .nextCard, title: "Onboarding/Onboarding.Sync.Skip.Action.v114")), image: .syncDevices, order: 20, prerequisites: ["ALWAYS"], title: "Onboarding/Onboarding.Sync.Title.v120", type: .freshInstall), "update-sign-to-sync": NimbusOnboardingCardData(body: "Upgrade/Upgrade.SyncSign.Description.v114", buttons: NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .syncSignIn, title: "Upgrade/Upgrade.SyncSign.Action.v114"), secondary: NimbusOnboardingButton(action: .nextCard, title: "Onboarding/Onboarding.LaterAction.v114")), image: .syncDevices, order: 20, prerequisites: ["NEVER"], title: "Upgrade/Upgrade.SyncSign.Title.v114", type: .upgrade), "update-welcome": NimbusOnboardingCardData(body: "Upgrade/Upgrade.Welcome.Description.v114", buttons: NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .nextCard, title: "Upgrade/Upgrade.Welcome.Action.v114")), image: .welcomeGlobe, order: 10, prerequisites: ["NEVER"], title: "Upgrade/Upgrade.Welcome.Title.v114", type: .upgrade), "welcome": NimbusOnboardingCardData(body: "Onboarding/Onboarding.Welcome.Description.TreatementA.v120", buttons: NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .openInstructionsPopup, title: "Onboarding/Onboarding.Welcome.ActionTreatementA.v114"), secondary: NimbusOnboardingButton(action: .nextCard, title: "Onboarding/Onboarding.Welcome.Skip.v114")), image: .welcomeGlobe, instructionsPopup: NimbusInstructionPopup(buttonAction: .openIosFxSettings, buttonTitle: "Onboarding/DefaultBrowserPopup.ButtonTitle.v114", instructions: ["Onboarding/DefaultBrowserPopup.FirstLabel.v114", "Onboarding/DefaultBrowserPopup.SecondLabel.v114", "Onboarding/DefaultBrowserPopup.ThirdLabel.v114"], title: "Onboarding/DefaultBrowserPopup.Title.v114"), link: NimbusOnboardingLink(title: "Onboarding/Onboarding.Welcome.Link.Action.v114", url: "https://www.mozilla.org/privacy/firefox/"), order: 10, prerequisites: ["ALWAYS"], title: "Onboarding/Onboarding.Welcome.Title.TreatementA.v120", type: .freshInstall)],
        conditions: [String: String] = ["ALWAYS": "true", "NEVER": "false"],
        dismissable: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            cards: cards,
            conditions: conditions,
            dismissable: dismissable))
    }

    enum CodingKeys: String, CodingKey {
        case cards = "cards"
        case conditions = "conditions"
        case dismissable = "dismissable"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(cards, forKey: .cards)
        try container.encode(conditions, forKey: .conditions)
        try container.encode(dismissable, forKey: .dismissable)
    }

    /// The list of available cards for onboarding.
     /// 
    public lazy var cards: [String: NimbusOnboardingCardData] = {
        self._variables.getVariablesMap("cards")?.mapValuesNotNull(NimbusOnboardingCardData.create).mergeWith(_defaults.cards, NimbusOnboardingCardData.mergeWith) ?? _defaults.cards
    }()
    
    /// A collection of out the box conditional expressions to be used in
     /// determining whether a card should show or not. Each entry maps to a
     /// valid JEXL expression.
     /// 
    public lazy var conditions: [String: String] = {
        self._variables.getStringMap("conditions")?.mergeWith(_defaults.conditions) ?? _defaults.conditions
    }()
    
    /// Whether or not the entire onboarding is dismissable by pressing an X at the
     /// top right corner of the screen.
     /// 
    public lazy var dismissable: Bool = {
        self._variables.getBool("dismissable") ?? _defaults.dismissable
    }()
    
}
extension OnboardingFrameworkFeature: FMLFeatureInterface {}
/// The feature for managing the roll out of the qrCode coordinator.
 /// 
public class QrCodeCoordinatorRefactor: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
    }

    /// Enables the feature
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
}
extension QrCodeCoordinatorRefactor: FMLFeatureInterface {}
/// Configuring the functionality to do with search. This will be separated into
 /// smaller sub-features in later releases.
 /// 
public class Search: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let awesomeBar: AwesomeBar
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        awesomeBar: AwesomeBar = AwesomeBar(position: SearchBarPositionFeature(isBottom: false, isPositionFeatureEnabled: true, isToolbarCfrOn: false), searchHighlights: false, usePageContent: false)
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            awesomeBar: awesomeBar))
    }

    enum CodingKeys: String, CodingKey {
        case awesomeBar = "awesome-bar"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(awesomeBar, forKey: .awesomeBar)
    }

    /// Configuring the awesome bar.
    public lazy var awesomeBar: AwesomeBar = {
        self._variables.getVariables("awesome-bar")?.map(AwesomeBar.create)._mergeWith(_defaults.awesomeBar) ?? _defaults.awesomeBar
    }()
    
}
extension Search: FMLFeatureInterface {}
/// The feature that controls whether or not search term groups are enabled.
public class SearchTermGroupsFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let groupingEnabled: [SearchTermGroups: Bool]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        groupingEnabled: [SearchTermGroups: Bool] = [.historyGroups: true, .tabTrayGroups: true]
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            groupingEnabled: groupingEnabled))
    }

    enum CodingKeys: String, CodingKey {
        case groupingEnabled = "grouping-enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(groupingEnabled.mapKeysNotNull { $0.rawValue }, forKey: .groupingEnabled)
    }

    /// This property provides a lookup table of whether or not the given grouping
     /// should be enabled.
    public lazy var groupingEnabled: [SearchTermGroups: Bool] = {
        self._variables.getBoolMap("grouping-enabled")?.mapKeysNotNull(SearchTermGroups.enumValue).mergeWith(_defaults.groupingEnabled) ?? _defaults.groupingEnabled
    }()
    
}
extension SearchTermGroupsFeature: FMLFeatureInterface {}
/// This feature define the redesign of the share sheet
public class ShareSheet: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let moveActions: Bool
        let toolbarChanges: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        moveActions: Bool = true,
        toolbarChanges: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            moveActions: moveActions,
            toolbarChanges: toolbarChanges))
    }

    enum CodingKeys: String, CodingKey {
        case moveActions = "move-actions"
        case toolbarChanges = "toolbar-changes"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(moveActions, forKey: .moveActions)
        try container.encode(toolbarChanges, forKey: .toolbarChanges)
    }

    /// If true copy and send to device are moved to share sheet
    public lazy var moveActions: Bool = {
        self._variables.getBool("move-actions") ?? _defaults.moveActions
    }()
    
    /// If true share option is shown on the toolbar
    public lazy var toolbarChanges: Bool = {
        self._variables.getBool("toolbar-changes") ?? _defaults.toolbarChanges
    }()
    
}
extension ShareSheet: FMLFeatureInterface {}
/// The configuration setting for the status of the Fakespot feature
 /// 
public class Shopping2023: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let backInStockReporting: Bool
        let config: [String: WebsiteConfig]
        let productAds: Bool
        let relay: String
        let status: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        backInStockReporting: Bool = true,
        config: [String: WebsiteConfig] = ["amazon": WebsiteConfig(productIdFromUrlRegex: "(?:[\\/]|$|%2F)(?<productId>[A-Z0-9]{10})(?:[\\/]|$|\\#|\\?|%2F)", validTlDs: ["com", "de", "fr"]), "bestbuy": WebsiteConfig(productIdFromUrlRegex: "\\/(?<productId>\\d+\\.p)", validTlDs: ["com"]), "walmart": WebsiteConfig(productIdFromUrlRegex: "\\/ip\\/(?:[A-Za-z0-9-]{1,320}\\/)?(?<productId>[0-9]{3,13})", validTlDs: ["com"])],
        productAds: Bool = true,
        relay: String = "https://mozilla-ohttp-fakespot.fastly-edge.com/",
        status: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            backInStockReporting: backInStockReporting,
            config: config,
            productAds: productAds,
            relay: relay,
            status: status))
    }

    enum CodingKeys: String, CodingKey {
        case backInStockReporting = "back_in_stock_reporting"
        case config = "config"
        case productAds = "product_ads"
        case relay = "relay"
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(backInStockReporting, forKey: .backInStockReporting)
        try container.encode(config, forKey: .config)
        try container.encode(productAds, forKey: .productAds)
        try container.encode(relay, forKey: .relay)
        try container.encode(status, forKey: .status)
    }

    /// If true, enables for users the reporting feature for products back in stock.
     /// 
    public lazy var backInStockReporting: Bool = {
        self._variables.getBool("back_in_stock_reporting") ?? _defaults.backInStockReporting
    }()
    
    /// A Map of website configurations
     /// 
    public lazy var config: [String: WebsiteConfig] = {
        self._variables.getVariablesMap("config")?.mapValuesNotNull(WebsiteConfig.create).mergeWith(_defaults.config, WebsiteConfig.mergeWith) ?? _defaults.config
    }()
    
    /// If true, enables the product advertisement feature, allowing users to see
     /// and interact with ads for various products.
     /// 
    public lazy var productAds: Bool = {
        self._variables.getBool("product_ads") ?? _defaults.productAds
    }()
    
    /// Configurable relay URL for production environment
     /// 
    public lazy var relay: String = {
        self._variables.getString("relay") ?? _defaults.relay
    }()
    
    /// Whether the Fakespot feature is enabled or disabled
     /// 
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
    
}
extension Shopping2023: FMLFeatureInterface {}
/// Add pages as items findable with Spotlight.
public class SpotlightSearch: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
        let iconType: IconType?
        let keepForDays: Int?
        let searchableContent: PageContent?
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = true,
        iconType: IconType? = .screenshot,
        keepForDays: Int? = nil,
        searchableContent: PageContent? = .textExcerpt
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled,
            iconType: iconType,
            keepForDays: keepForDays,
            searchableContent: searchableContent))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
        case iconType = "icon-type"
        case keepForDays = "keep-for-days"
        case searchableContent = "searchable-content"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
        try container.encode(iconType?.rawValue, forKey: .iconType)
        try container.encode(keepForDays, forKey: .keepForDays)
        try container.encode(searchableContent?.rawValue, forKey: .searchableContent)
    }

    /// If this is true, then on each page load adds a new item to Spotlight.
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
    /// The icon that is displayed next to the item in the search results. If this
     /// is `null`, then no icon is displayed.
     /// 
    public lazy var iconType: IconType? = {
        self._variables.getString("icon-type")?.map(IconType.enumValue) ?? _defaults.iconType
    }()
    
    /// Number of days to keep the item before automatic deletion. If this is left
     /// `null`, then it is left to iOS's default.
     /// 
    public lazy var keepForDays: Int? = {
        self._variables.getInt("keep-for-days") ?? _defaults.keepForDays
    }()
    
    /// The text content that is made searchable. If this is `null` then no
     /// additional content is used, and only the title and URL will be used.
     /// 
    public lazy var searchableContent: PageContent? = {
        self._variables.getString("searchable-content")?.map(PageContent.enumValue) ?? _defaults.searchableContent
    }()
    
}
extension SpotlightSearch: FMLFeatureInterface {}
/// This feature is for managing the roll out of the Tab Tray refactor feature
 /// 
public class TabTrayRefactorFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let enabled: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        enabled: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            enabled: enabled))
    }

    enum CodingKeys: String, CodingKey {
        case enabled = "enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(enabled, forKey: .enabled)
    }

    /// Enables the feature
     /// 
    public lazy var enabled: Bool = {
        self._variables.getBool("enabled") ?? _defaults.enabled
    }()
    
}
extension TabTrayRefactorFeature: FMLFeatureInterface {}
/// The tab tray screen that the user goes to when they open the tab tray.
public class TabTrayFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let sectionsEnabled: [TabTraySection: Bool]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        sectionsEnabled: [TabTraySection: Bool] = [.inactiveTabs: true]
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            sectionsEnabled: sectionsEnabled))
    }

    enum CodingKeys: String, CodingKey {
        case sectionsEnabled = "sections-enabled"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(sectionsEnabled.mapKeysNotNull { $0.rawValue }, forKey: .sectionsEnabled)
    }

    /// This property provides a lookup table of whether or not the given section
     /// should be enabled. If the section is enabled, it should be toggleable
     /// in the settings screen, and on by default.
    public lazy var sectionsEnabled: [TabTraySection: Bool] = {
        self._variables.getBoolMap("sections-enabled")?.mapKeysNotNull(TabTraySection.enumValue).mergeWith(_defaults.sectionsEnabled) ?? _defaults.sectionsEnabled
    }()
    
}
extension TabTrayFeature: FMLFeatureInterface {}
/// This property defines the configuration for the wallpaper feature
public class WallpaperFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let configuration: WallpaperConfiguration
        let onboardingSheet: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        configuration: WallpaperConfiguration = WallpaperConfiguration(status: true, version: .v1),
        onboardingSheet: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            configuration: configuration,
            onboardingSheet: onboardingSheet))
    }

    enum CodingKeys: String, CodingKey {
        case configuration = "configuration"
        case onboardingSheet = "onboarding-sheet"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(configuration, forKey: .configuration)
        try container.encode(onboardingSheet, forKey: .onboardingSheet)
    }

    /// This property defines the configuration for the wallpaper feature
    public lazy var configuration: WallpaperConfiguration = {
        self._variables.getVariables("configuration")?.map(WallpaperConfiguration.create)._mergeWith(_defaults.configuration) ?? _defaults.configuration
    }()
    
    /// This property defines whether the wallpaper onboarding is shown or not
    public lazy var onboardingSheet: Bool = {
        self._variables.getBool("onboarding-sheet") ?? _defaults.onboardingSheet
    }()
    
}
extension WallpaperFeature: FMLFeatureInterface {}
/// The configuration for the status of the zoom feature
 /// 
public class ZoomFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let status: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        status: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            status: status))
    }

    enum CodingKeys: String, CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(status, forKey: .status)
    }

    /// Whether the page zoom feature is enabled or not
     /// 
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
    
}
extension ZoomFeature: FMLFeatureInterface {}


/// The identifiers for a individual contextual hints.
public enum ContextualHint: String, CaseIterable, Codable {
    
    /// The contextual hint bubble that appears to provide a hint about the toolbar.
    case toolbarHint = "toolbar-hint"
    

    public static func enumValue(_ s: String?) -> ContextualHint? {
        guard let s = s else {
            return nil
        }
        return ContextualHint(rawValue: s)
    }
}


/// An enum to influence what should be displayed when a control message is
 /// selected.
public enum ControlMessageBehavior: String, CaseIterable, Codable {
    
    /// The next eligible message should be shown.
    case showNextMessage = "show-next-message"
    
    /// The surface should show no message.
    case showNone = "show-none"
    

    public static func enumValue(_ s: String?) -> ControlMessageBehavior? {
        guard let s = s else {
            return nil
        }
        return ControlMessageBehavior(rawValue: s)
    }
}


/// The identifiers for the sections of the homescreen.
public enum HomeScreenSection: String, CaseIterable, Codable {
    
    /// The tabs the user was looking immediately before being interrupted.
    case jumpBackIn = "jump-back-in"
    
    /// The tab groups
    case recentExplorations = "recent-explorations"
    

    public static func enumValue(_ s: String?) -> HomeScreenSection? {
        guard let s = s else {
            return nil
        }
        return HomeScreenSection(rawValue: s)
    }
}


/// The icon that will be added to the item in the device's search engine.
public enum IconType: String, CaseIterable, Codable {
    
    /// The favicon of the page
    case favicon = "favicon"
    
    /// An icon generated from the first letter of the base domain.
    case letter = "letter"
    
    /// A screenshot of the page at load time.
    case screenshot = "screenshot"
    

    public static func enumValue(_ s: String?) -> IconType? {
        guard let s = s else {
            return nil
        }
        return IconType(rawValue: s)
    }
}


/// For messaging, we would like to have a message tell us which surface its
 /// associated with. This is a label that matches across both Android and iOS.
 /// 
public enum MessageSurfaceId: String, CaseIterable, Codable {
    
    /// A message has NOT declared its target surface.
    case unknown = "Unknown"
    
    /// This is the card that appears at the top on the Firefox Home Page.
    case newTabCard = "new-tab-card"
    
    /// This is a local notification send to the user periodically with tips and
     /// updates.
    case notification = "notification"
    
    /// This is a full-page that appears providing a survey to the user.
    case survey = "survey"
    

    public static func enumValue(_ s: String?) -> MessageSurfaceId? {
        guard let s = s else {
            return nil
        }
        return MessageSurfaceId(rawValue: s)
    }
}


/// The identifiers for the different images available for cards in onboarding
 /// 
public enum NimbusOnboardingImages: String, CaseIterable, Codable {
    
    /// Corresponding to the notifications image
     /// 
    case notifications = "notifications"
    
    /// Corresponding to the notifications image for CTD
     /// 
    case notificationsCtd = "notifications-ctd"
    
    /// Corresponding to the fox search widget image
     /// 
    case searchWidget = "search-widget"
    
    /// Corresponding to the set to dock image
     /// 
    case setToDock = "set-to-dock"
    
    /// Corresponding to the sync-devices image
     /// 
    case syncDevices = "sync-devices"
    
    /// Corresponding to the sync image for CTD
     /// 
    case syncDevicesCtd = "sync-devices-ctd"
    
    /// Corresponding to the welcome image for CTD
     /// 
    case welcomeCtd = "welcome-ctd"
    
    /// Corresponding to the fox world image
     /// 
    case welcomeGlobe = "welcome-globe"
    

    public static func enumValue(_ s: String?) -> NimbusOnboardingImages? {
        guard let s = s else {
            return nil
        }
        return NimbusOnboardingImages(rawValue: s)
    }
}


/// The identifiers for the different actions available for cards in onboarding
 /// 
public enum OnboardingActions: String, CaseIterable, Codable {
    
    /// Will take the user to the next card
     /// 
    case nextCard = "next-card"
    
    /// Will open up a popup with instructions for something
     /// 
    case openInstructionsPopup = "open-instructions-popup"
    
    /// Will open a webview where the user can read the privacy policy
     /// 
    case readPrivacyPolicy = "read-privacy-policy"
    
    /// Will request to allow notifications from the user
     /// 
    case requestNotifications = "request-notifications"
    
    /// Will send the user to settings to set Firefox as their default browser
     /// 
    case setDefaultBrowser = "set-default-browser"
    
    /// Will take the user to the sync sign in flow
     /// 
    case syncSignIn = "sync-sign-in"
    

    public static func enumValue(_ s: String?) -> OnboardingActions? {
        guard let s = s else {
            return nil
        }
        return OnboardingActions(rawValue: s)
    }
}


/// The identifiers for the different actions available for the insturction card
 /// in onboarding
 /// 
public enum OnboardingInstructionsPopupActions: String, CaseIterable, Codable {
    
    /// Will dismiss the popup
     /// 
    case dismiss = "dismiss"
    
    /// Will dismiss the popup and move to the next card
     /// 
    case dismissAndNextCard = "dismiss-and-next-card"
    
    /// Will take the user to the default browser settings in the iOS system
     /// settings
     /// 
    case openIosFxSettings = "open-ios-fx-settings"
    

    public static func enumValue(_ s: String?) -> OnboardingInstructionsPopupActions? {
        guard let s = s else {
            return nil
        }
        return OnboardingInstructionsPopupActions(rawValue: s)
    }
}


/// The identifiers for the different types of onboarding cards.
 /// 
public enum OnboardingType: String, CaseIterable, Codable {
    
    /// Corresponding to onboarding cards that are for new users
     /// 
    case freshInstall = "fresh-install"
    
    /// Corresponding to onboarding cards that are for users who have updated
     /// 
    case upgrade = "upgrade"
    

    public static func enumValue(_ s: String?) -> OnboardingType? {
        guard let s = s else {
            return nil
        }
        return OnboardingType(rawValue: s)
    }
}


/// The page content that will be added as an item in the device's search
 /// engine.
public enum PageContent: String, CaseIterable, Codable {
    
    /// Use all the page as HTML
    case htmlContent = "html-content"
    
    /// Use all the page as text
    case textContent = "text-content"
    
    /// Only use the first paragraph
    case textExcerpt = "text-excerpt"
    

    public static func enumValue(_ s: String?) -> PageContent? {
        guard let s = s else {
            return nil
        }
        return PageContent(rawValue: s)
    }
}


/// The identifiers for the different types of search term groups.
public enum SearchTermGroups: String, CaseIterable, Codable {
    
    /// Grouping for items in History and RecentlyVisited
    case historyGroups = "history-groups"
    
    /// Grouping for items in the Tab Tray and in JumpBackIn
    case tabTrayGroups = "tab-tray-groups"
    

    public static func enumValue(_ s: String?) -> SearchTermGroups? {
        guard let s = s else {
            return nil
        }
        return SearchTermGroups(rawValue: s)
    }
}


/// The identifiers for the sections of the tab tray.
public enum TabTraySection: String, CaseIterable, Codable {
    
    /// Tabs that have been automatically closed for the user.
    case inactiveTabs = "inactive-tabs"
    

    public static func enumValue(_ s: String?) -> TabTraySection? {
        guard let s = s else {
            return nil
        }
        return TabTraySection(rawValue: s)
    }
}


/// An enum to identify which version of the wallpaper system to use
public enum WallpaperVariantVersion: String, CaseIterable, Codable {
    
    /// The legacy wallpaper version
    case legacy = "legacy"
    
    /// The 2022 MR version
    case v1 = "v1"
    

    public static func enumValue(_ s: String?) -> WallpaperVariantVersion? {
        guard let s = s else {
            return nil
        }
        return WallpaperVariantVersion(rawValue: s)
    }
}

/// A configuration option for the awesome bar. Part of the `search` feature.
public class AwesomeBar: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let minSearchTerm: Int
        let position: SearchBarPositionFeature
        let searchHighlights: Bool
        let usePageContent: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        minSearchTerm: Int = 3,
        position: SearchBarPositionFeature = SearchBarPositionFeature(isBottom: true, isPositionFeatureEnabled: true, isToolbarCfrOn: true),
        searchHighlights: Bool = false,
        usePageContent: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            minSearchTerm: minSearchTerm,
            position: position,
            searchHighlights: searchHighlights,
            usePageContent: usePageContent))
    }

    enum CodingKeys: String, CodingKey {
        case minSearchTerm = "min-search-term"
        case position = "position"
        case searchHighlights = "search-highlights"
        case usePageContent = "use-page-content"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(minSearchTerm, forKey: .minSearchTerm)
        try container.encode(position, forKey: .position)
        try container.encode(searchHighlights, forKey: .searchHighlights)
        try container.encode(usePageContent, forKey: .usePageContent)
    }

    /// The minimum number of characters that the user types before searching in
     /// the page.
    public lazy var minSearchTerm: Int = {
        self._variables.getInt("min-search-term") ?? _defaults.minSearchTerm
    }()
    
    /// This property defines whether or not the feature is enabled, and the
     /// position of the search bar
     /// 
    public lazy var position: SearchBarPositionFeature = {
        self._variables.getVariables("position")?.map(SearchBarPositionFeature.create)._mergeWith(_defaults.position) ?? _defaults.position
    }()
    
    /// Whether or not search highlights are enabled
    public lazy var searchHighlights: Bool = {
        self._variables.getBool("search-highlights") ?? _defaults.searchHighlights
    }()
    
    /// Search in the open tab's text content when typing.
    public lazy var usePageContent: Bool = {
        self._variables.getBool("use-page-content") ?? _defaults.usePageContent
    }()
    
}

public extension AwesomeBar {
    func _mergeWith(_ defaults: AwesomeBar?) -> AwesomeBar {
        guard let defaults = defaults else {
            return self
        }
        return AwesomeBar(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> AwesomeBar {
        return AwesomeBar(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: AwesomeBar, _ defaults: AwesomeBar) -> AwesomeBar {
        return overrides._mergeWith(defaults)
    }
}

/// The configuration for the a feature that can be enabled or disabled
public class GeneralFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let status: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        status: Bool = false
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            status: status))
    }

    enum CodingKeys: String, CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(status, forKey: .status)
    }

    /// Whether or not the feature is enabled
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
    
}

public extension GeneralFeature {
    func _mergeWith(_ defaults: GeneralFeature?) -> GeneralFeature {
        guard let defaults = defaults else {
            return self
        }
        return GeneralFeature(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> GeneralFeature {
        return GeneralFeature(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: GeneralFeature, _ defaults: GeneralFeature) -> GeneralFeature {
        return overrides._mergeWith(defaults)
    }
}

/// An object to describe a message. It uses human readable strings to describe
 /// the triggers, action and style of the message as well as the text of the
 /// message and call to action.
 /// 
public class MessageData: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let action: String
        let buttonLabel: String?
        let experiment: String?
        let isControl: Bool
        let style: String
        let surface: MessageSurfaceId
        let text: String
        let title: String?
        let trigger: [String]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        action: String = "",
        buttonLabel: String? = nil,
        experiment: String? = nil,
        isControl: Bool = false,
        style: String = "DEFAULT",
        surface: MessageSurfaceId = .unknown,
        text: String = "",
        title: String? = nil,
        trigger: [String] = []
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            action: action,
            buttonLabel: buttonLabel,
            experiment: experiment,
            isControl: isControl,
            style: style,
            surface: surface,
            text: text,
            title: title,
            trigger: trigger))
    }

    enum CodingKeys: String, CodingKey {
        case action = "action"
        case buttonLabel = "button-label"
        case experiment = "experiment"
        case isControl = "is-control"
        case style = "style"
        case surface = "surface"
        case text = "text"
        case title = "title"
        case trigger = "trigger"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(action, forKey: .action)
        try container.encode(buttonLabel, forKey: .buttonLabel)
        try container.encode(experiment, forKey: .experiment)
        try container.encode(isControl, forKey: .isControl)
        try container.encode(style, forKey: .style)
        try container.encode(surface.rawValue, forKey: .surface)
        try container.encode(text, forKey: .text)
        try container.encode(title, forKey: .title)
        try container.encode(trigger, forKey: .trigger)
    }

    /// A URL of a page or a deeplink. This may have substitution variables in.
     /// 
    public lazy var action: String = {
        self._variables.getString("action") ?? _defaults.action
    }()
    
    /// The text on the button. If no text is present, the whole message is
     /// clickable.
     /// 
    public lazy var buttonLabel: String? = {
        self._variables.getText("button-label") ?? _defaults.buttonLabel.map { self._variables.resourceBundles.getString(named: $0) ?? $0 }
    }()
    
    /// The experiment slug that this message is involved in.
    public lazy var experiment: String? = {
        self._variables.getString("experiment") ?? _defaults.experiment
    }()
    
    /// Indicates if this message is the control message, if true shouldn't be
     /// displayed
    public lazy var isControl: Bool = {
        self._variables.getBool("is-control") ?? _defaults.isControl
    }()
    
    /// The style as described in a `StyleData` from the styles table.
     /// 
    public lazy var style: String = {
        self._variables.getString("style") ?? _defaults.style
    }()
    
    /// Each message will tell us the surface it is targeting with this.
    public lazy var surface: MessageSurfaceId = {
        self._variables.getString("surface")?.map(MessageSurfaceId.enumValue) ?? _defaults.surface
    }()
    
    /// The message text displayed to the user
    public lazy var text: String = {
        self._variables.getText("text") ?? self._variables.resourceBundles.getString(named: _defaults.text) ?? _defaults.text
    }()
    
    /// The title text displayed to the user
    public lazy var title: String? = {
        self._variables.getText("title") ?? _defaults.title.map { self._variables.resourceBundles.getString(named: $0) ?? $0 }
    }()
    
    /// A list of strings corresponding to targeting expressions. The message will
     /// be shown if all expressions `true`.
     /// 
    public lazy var trigger: [String] = {
        self._variables.getStringList("trigger") ?? _defaults.trigger
    }()
    
}

public extension MessageData {
    func _mergeWith(_ defaults: MessageData?) -> MessageData {
        guard let defaults = defaults else {
            return self
        }
        return MessageData(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> MessageData {
        return MessageData(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: MessageData, _ defaults: MessageData) -> MessageData {
        return overrides._mergeWith(defaults)
    }
}

/// The object outlining the content of the instruction card.
 /// 
public class NimbusInstructionPopup: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let buttonAction: OnboardingInstructionsPopupActions
        let buttonTitle: String
        let instructions: [String]
        let title: String
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        buttonAction: OnboardingInstructionsPopupActions = .dismissAndNextCard,
        buttonTitle: String = "",
        instructions: [String] = [],
        title: String = ""
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            buttonAction: buttonAction,
            buttonTitle: buttonTitle,
            instructions: instructions,
            title: title))
    }

    enum CodingKeys: String, CodingKey {
        case buttonAction = "button-action"
        case buttonTitle = "button-title"
        case instructions = "instructions"
        case title = "title"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(buttonAction.rawValue, forKey: .buttonAction)
        try container.encode(buttonTitle, forKey: .buttonTitle)
        try container.encode(instructions, forKey: .instructions)
        try container.encode(title, forKey: .title)
    }

    /// The action the button should have. Default is `dismiss-and-next-card`
     /// 
    public lazy var buttonAction: OnboardingInstructionsPopupActions = {
        self._variables.getString("button-action")?.map(OnboardingInstructionsPopupActions.enumValue) ?? _defaults.buttonAction
    }()
    
    /// The title the button should have. This should never be defaulted.
     /// 
    public lazy var buttonTitle: String = {
        self._variables.getText("button-title") ?? self._variables.resourceBundles.getString(named: _defaults.buttonTitle) ?? _defaults.buttonTitle
    }()
    
    /// A list of instructions, either as free text, or as Text identifiers.
     /// 
    public lazy var instructions: [String] = {
        self._variables.getTextList("instructions") ?? _defaults.instructions.map { self._variables.resourceBundles.getString(named: $0) ?? $0 }
    }()
    
    /// The text of the popup. This should never be defaulted.
     /// 
    public lazy var title: String = {
        self._variables.getText("title") ?? self._variables.resourceBundles.getString(named: _defaults.title) ?? _defaults.title
    }()
    
}

public extension NimbusInstructionPopup {
    func _mergeWith(_ defaults: NimbusInstructionPopup?) -> NimbusInstructionPopup {
        guard let defaults = defaults else {
            return self
        }
        return NimbusInstructionPopup(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> NimbusInstructionPopup {
        return NimbusInstructionPopup(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: NimbusInstructionPopup, _ defaults: NimbusInstructionPopup) -> NimbusInstructionPopup {
        return overrides._mergeWith(defaults)
    }
}

/// A group of properties describing the attributes of a card.
 /// 
public class NimbusOnboardingButton: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let action: OnboardingActions
        let title: String
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        action: OnboardingActions = .nextCard,
        title: String = ""
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            action: action,
            title: title))
    }

    enum CodingKeys: String, CodingKey {
        case action = "action"
        case title = "title"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(action.rawValue, forKey: .action)
        try container.encode(title, forKey: .title)
    }

    /// The action the button should take. The default for this will be "next-card"
     /// 
    public lazy var action: OnboardingActions = {
        self._variables.getString("action")?.map(OnboardingActions.enumValue) ?? _defaults.action
    }()
    
    /// The text of the button title. This should never be defaulted.
     /// 
    public lazy var title: String = {
        self._variables.getText("title") ?? self._variables.resourceBundles.getString(named: _defaults.title) ?? _defaults.title
    }()
    
}

public extension NimbusOnboardingButton {
    func _mergeWith(_ defaults: NimbusOnboardingButton?) -> NimbusOnboardingButton {
        guard let defaults = defaults else {
            return self
        }
        return NimbusOnboardingButton(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> NimbusOnboardingButton {
        return NimbusOnboardingButton(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: NimbusOnboardingButton, _ defaults: NimbusOnboardingButton) -> NimbusOnboardingButton {
        return overrides._mergeWith(defaults)
    }
}

/// A set of buttons for the card. There can be up to two, but there must be at
 /// least one.
 /// 
public class NimbusOnboardingButtons: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let primary: NimbusOnboardingButton
        let secondary: NimbusOnboardingButton?
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        primary: NimbusOnboardingButton = NimbusOnboardingButton(action: .nextCard, title: "Primary Button"),
        secondary: NimbusOnboardingButton? = nil
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            primary: primary,
            secondary: secondary))
    }

    enum CodingKeys: String, CodingKey {
        case primary = "primary"
        case secondary = "secondary"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(primary, forKey: .primary)
        try container.encode(secondary, forKey: .secondary)
    }

    /// The primary button for the card. This must exist.
     /// 
    public lazy var primary: NimbusOnboardingButton = {
        self._variables.getVariables("primary")?.map(NimbusOnboardingButton.create)._mergeWith(_defaults.primary) ?? _defaults.primary
    }()
    
    /// A secondary, optional, button for the card.
     /// 
    public lazy var secondary: NimbusOnboardingButton? = {
        self._variables.getVariables("secondary")?.map(NimbusOnboardingButton.create)._mergeWith(_defaults.secondary) ?? _defaults.secondary
    }()
    
}

public extension NimbusOnboardingButtons {
    func _mergeWith(_ defaults: NimbusOnboardingButtons?) -> NimbusOnboardingButtons {
        guard let defaults = defaults else {
            return self
        }
        return NimbusOnboardingButtons(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> NimbusOnboardingButtons {
        return NimbusOnboardingButtons(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: NimbusOnboardingButtons, _ defaults: NimbusOnboardingButtons) -> NimbusOnboardingButtons {
        return overrides._mergeWith(defaults)
    }
}

/// A group of properties describing the attributes of a card.
 /// 
public class NimbusOnboardingCardData: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let body: String
        let buttons: NimbusOnboardingButtons
        let disqualifiers: [String]
        let image: NimbusOnboardingImages
        let instructionsPopup: NimbusInstructionPopup?
        let link: NimbusOnboardingLink?
        let order: Int
        let prerequisites: [String]
        let title: String
        let type: OnboardingType
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        body: String = "",
        buttons: NimbusOnboardingButtons = NimbusOnboardingButtons(primary: NimbusOnboardingButton(action: .nextCard, title: "Onboarding/Onboarding.Sync.Skip.Action.v114"), secondary: nil),
        disqualifiers: [String] = [],
        image: NimbusOnboardingImages = .welcomeGlobe,
        instructionsPopup: NimbusInstructionPopup? = nil,
        link: NimbusOnboardingLink? = nil,
        order: Int = 10,
        prerequisites: [String] = [],
        title: String = "",
        type: OnboardingType = .freshInstall
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            body: body,
            buttons: buttons,
            disqualifiers: disqualifiers,
            image: image,
            instructionsPopup: instructionsPopup,
            link: link,
            order: order,
            prerequisites: prerequisites,
            title: title,
            type: type))
    }

    enum CodingKeys: String, CodingKey {
        case body = "body"
        case buttons = "buttons"
        case disqualifiers = "disqualifiers"
        case image = "image"
        case instructionsPopup = "instructions-popup"
        case link = "link"
        case order = "order"
        case prerequisites = "prerequisites"
        case title = "title"
        case type = "type"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(body, forKey: .body)
        try container.encode(buttons, forKey: .buttons)
        try container.encode(disqualifiers, forKey: .disqualifiers)
        try container.encode(image.rawValue, forKey: .image)
        try container.encode(instructionsPopup, forKey: .instructionsPopup)
        try container.encode(link, forKey: .link)
        try container.encode(order, forKey: .order)
        try container.encode(prerequisites, forKey: .prerequisites)
        try container.encode(title, forKey: .title)
        try container.encode(type.rawValue, forKey: .type)
    }

    /// The body text dispalyed on the card, in less prominent text. This should
     /// never be defaulted.
     /// 
    public lazy var body: String = {
        self._variables.getText("body") ?? self._variables.resourceBundles.getString(named: _defaults.body) ?? _defaults.body
    }()
    
    /// The set of buttons associated with the card.
     /// 
    public lazy var buttons: NimbusOnboardingButtons = {
        self._variables.getVariables("buttons")?.map(NimbusOnboardingButtons.create)._mergeWith(_defaults.buttons) ?? _defaults.buttons
    }()
    
    /// A list of ConditionName strings corresponding to targeting expressions. The
     /// card will not be shown if any expression is `true`.
     /// 
    public lazy var disqualifiers: [String] = {
        self._variables.getStringList("disqualifiers") ?? _defaults.disqualifiers
    }()
    
    /// The image that should be dispalyed on the card.
     /// 
    public lazy var image: NimbusOnboardingImages = {
        self._variables.getString("image")?.map(NimbusOnboardingImages.enumValue) ?? _defaults.image
    }()
    
    /// The object describing the specific instruction popup button for a card. If
     /// left empty, the card will have no instruction popup information
     /// 
    public lazy var instructionsPopup: NimbusInstructionPopup? = {
        self._variables.getVariables("instructions-popup")?.map(NimbusInstructionPopup.create)._mergeWith(_defaults.instructionsPopup) ?? _defaults.instructionsPopup
    }()
    
    /// The object describing the link button for a card. If left empty, the card
     /// will have no link.
     /// 
    public lazy var link: NimbusOnboardingLink? = {
        self._variables.getVariables("link")?.map(NimbusOnboardingLink.create)._mergeWith(_defaults.link) ?? _defaults.link
    }()
    
    /// The place in the order where the card will be found. The feature layer will
     /// then sort the cards based on this field.
     /// 
    public lazy var order: Int = {
        self._variables.getInt("order") ?? _defaults.order
    }()
    
    /// A list of ConditionName strings corresponding to targeting expressions. The
     /// card will be shown if all expressions `true` and if no expressions in
     /// the `disqualifiers` table are true, or if the `disqualifiers` table
     /// is empty.
     /// 
    public lazy var prerequisites: [String] = {
        self._variables.getStringList("prerequisites") ?? _defaults.prerequisites
    }()
    
    /// The title displayed on the card, in prominent, bolded text. This should
     /// never be defaulted.
     /// 
    public lazy var title: String = {
        self._variables.getText("title") ?? self._variables.resourceBundles.getString(named: _defaults.title) ?? _defaults.title
    }()
    
    /// The type of onboarding this card should be shown in, whether it a fresh
     /// install or an update. The default is fresh-install.
     /// 
    public lazy var type: OnboardingType = {
        self._variables.getString("type")?.map(OnboardingType.enumValue) ?? _defaults.type
    }()
    
}

public extension NimbusOnboardingCardData {
    func _mergeWith(_ defaults: NimbusOnboardingCardData?) -> NimbusOnboardingCardData {
        guard let defaults = defaults else {
            return self
        }
        return NimbusOnboardingCardData(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> NimbusOnboardingCardData {
        return NimbusOnboardingCardData(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: NimbusOnboardingCardData, _ defaults: NimbusOnboardingCardData) -> NimbusOnboardingCardData {
        return overrides._mergeWith(defaults)
    }
}

/// A group of properties describing the attributes for the active link on
 /// a card
 /// 
public class NimbusOnboardingLink: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let title: String
        let url: String
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        title: String = "Onboarding/Onboarding.Welcome.Link.Action.v114",
        url: String = "https://www.mozilla.org/privacy/firefox/"
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            title: title,
            url: url))
    }

    enum CodingKeys: String, CodingKey {
        case title = "title"
        case url = "url"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(title, forKey: .title)
        try container.encode(url, forKey: .url)
    }

    /// The text of the link title.
     /// 
    public lazy var title: String = {
        self._variables.getText("title") ?? self._variables.resourceBundles.getString(named: _defaults.title) ?? _defaults.title
    }()
    
    /// The url that the link will lead to.
     /// 
    public lazy var url: String = {
        self._variables.getString("url") ?? _defaults.url
    }()
    
}

public extension NimbusOnboardingLink {
    func _mergeWith(_ defaults: NimbusOnboardingLink?) -> NimbusOnboardingLink {
        guard let defaults = defaults else {
            return self
        }
        return NimbusOnboardingLink(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> NimbusOnboardingLink {
        return NimbusOnboardingLink(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: NimbusOnboardingLink, _ defaults: NimbusOnboardingLink) -> NimbusOnboardingLink {
        return overrides._mergeWith(defaults)
    }
}

/// The configuration for the bottom search bar on the homescreen
public class SearchBarPositionFeature: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let isBottom: Bool
        let isPositionFeatureEnabled: Bool
        let isToolbarCfrOn: Bool
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        isBottom: Bool = true,
        isPositionFeatureEnabled: Bool = true,
        isToolbarCfrOn: Bool = true
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            isBottom: isBottom,
            isPositionFeatureEnabled: isPositionFeatureEnabled,
            isToolbarCfrOn: isToolbarCfrOn))
    }

    enum CodingKeys: String, CodingKey {
        case isBottom = "is-bottom"
        case isPositionFeatureEnabled = "is-position-feature-enabled"
        case isToolbarCfrOn = "is-toolbar-cfr-on"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(isBottom, forKey: .isBottom)
        try container.encode(isPositionFeatureEnabled, forKey: .isPositionFeatureEnabled)
        try container.encode(isToolbarCfrOn, forKey: .isToolbarCfrOn)
    }

    /// Whether or not the default position is at the bottom
    public lazy var isBottom: Bool = {
        self._variables.getBool("is-bottom") ?? _defaults.isBottom
    }()
    
    /// Whether or not the feature is enabled
    public lazy var isPositionFeatureEnabled: Bool = {
        self._variables.getBool("is-position-feature-enabled") ?? _defaults.isPositionFeatureEnabled
    }()
    
    /// Whether or not the toolbar CFR shows. This is a temporary hack for Nimbus
    public lazy var isToolbarCfrOn: Bool = {
        self._variables.getBool("is-toolbar-cfr-on") ?? _defaults.isToolbarCfrOn
    }()
    
}

public extension SearchBarPositionFeature {
    func _mergeWith(_ defaults: SearchBarPositionFeature?) -> SearchBarPositionFeature {
        guard let defaults = defaults else {
            return self
        }
        return SearchBarPositionFeature(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> SearchBarPositionFeature {
        return SearchBarPositionFeature(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: SearchBarPositionFeature, _ defaults: SearchBarPositionFeature) -> SearchBarPositionFeature {
        return overrides._mergeWith(defaults)
    }
}

/// A group of properities (predominantly visual) to the describe style of the
 /// message.
 /// 
public class StyleData: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let maxDisplayCount: Int
        let priority: Int
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        maxDisplayCount: Int = 5,
        priority: Int = 50
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            maxDisplayCount: maxDisplayCount,
            priority: priority))
    }

    enum CodingKeys: String, CodingKey {
        case maxDisplayCount = "max-display-count"
        case priority = "priority"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(maxDisplayCount, forKey: .maxDisplayCount)
        try container.encode(priority, forKey: .priority)
    }

    /// How many sessions will this message be shown to the user before it is
     /// expired.
     /// 
    public lazy var maxDisplayCount: Int = {
        self._variables.getInt("max-display-count") ?? _defaults.maxDisplayCount
    }()
    
    /// The importance of this message. 0 is not very important, 100 is very
     /// important.
     /// 
    public lazy var priority: Int = {
        self._variables.getInt("priority") ?? _defaults.priority
    }()
    
}

public extension StyleData {
    func _mergeWith(_ defaults: StyleData?) -> StyleData {
        guard let defaults = defaults else {
            return self
        }
        return StyleData(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> StyleData {
        return StyleData(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: StyleData, _ defaults: StyleData) -> StyleData {
        return overrides._mergeWith(defaults)
    }
}

/// The configuration for the a feature that can be enabled or disabled
public class WallpaperConfiguration: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let status: Bool
        let version: WallpaperVariantVersion
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        status: Bool = false,
        version: WallpaperVariantVersion = .legacy
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            status: status,
            version: version))
    }

    enum CodingKeys: String, CodingKey {
        case status = "status"
        case version = "version"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(status, forKey: .status)
        try container.encode(version.rawValue, forKey: .version)
    }

    /// Whether or not the feature is enabled
    public lazy var status: Bool = {
        self._variables.getBool("status") ?? _defaults.status
    }()
    
    /// Which version of the wallpaper sytem to use
    public lazy var version: WallpaperVariantVersion = {
        self._variables.getString("version")?.map(WallpaperVariantVersion.enumValue) ?? _defaults.version
    }()
    
}

public extension WallpaperConfiguration {
    func _mergeWith(_ defaults: WallpaperConfiguration?) -> WallpaperConfiguration {
        guard let defaults = defaults else {
            return self
        }
        return WallpaperConfiguration(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> WallpaperConfiguration {
        return WallpaperConfiguration(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: WallpaperConfiguration, _ defaults: WallpaperConfiguration) -> WallpaperConfiguration {
        return overrides._mergeWith(defaults)
    }
}

/// It represents a configuration for different e-commerce websites and includes
 /// regular expressions for extracting product IDs from their respective URLs
 /// 
public class WebsiteConfig: FMLObjectInterface {
    private let _variables: Variables
    private let _defaults: Defaults
    private let _prefs: UserDefaults?

    private init(variables: Variables = NilVariables.instance, prefs: UserDefaults? = nil, defaults: Defaults) {
        self._variables = variables
        self._defaults = defaults
        self._prefs = prefs
    }
    
    struct Defaults {
        let productIdFromUrlRegex: String
        let validTlDs: [String]
    }

    public convenience init(
        _ _variables: Variables = NilVariables.instance,
        _ _prefs: UserDefaults? = nil,
        productIdFromUrlRegex: String = "",
        validTlDs: [String] = []
    ) {
        self.init(variables: _variables, prefs: _prefs, defaults: Defaults(
            productIdFromUrlRegex: productIdFromUrlRegex,
            validTlDs: validTlDs))
    }

    enum CodingKeys: String, CodingKey {
        case productIdFromUrlRegex = "productIdFromURLRegex"
        case validTlDs = "validTLDs"
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(productIdFromUrlRegex, forKey: .productIdFromUrlRegex)
        try container.encode(validTlDs, forKey: .validTlDs)
    }

    /// It represents the product ID extracted from a regex query
     /// 
    public lazy var productIdFromUrlRegex: String = {
        self._variables.getString("productIdFromURLRegex") ?? _defaults.productIdFromUrlRegex
    }()
    
    /// Valid Top Level Domains
     /// 
    public lazy var validTlDs: [String] = {
        self._variables.getStringList("validTLDs") ?? _defaults.validTlDs
    }()
    
}

public extension WebsiteConfig {
    func _mergeWith(_ defaults: WebsiteConfig?) -> WebsiteConfig {
        guard let defaults = defaults else {
            return self
        }
        return WebsiteConfig(variables: self._variables, prefs: self._prefs, defaults: defaults._defaults)
    }

    static func create(_ variables: Variables?) -> WebsiteConfig {
        return WebsiteConfig(variables ?? NilVariables.instance)
    }

    static func mergeWith(_ overrides: WebsiteConfig, _ defaults: WebsiteConfig) -> WebsiteConfig {
        return overrides._mergeWith(defaults)
    }
}

